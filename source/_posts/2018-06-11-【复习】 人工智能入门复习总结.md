---
title: 【复习】 人工智能入门复习总结
categories:
  - 复习
tags:
  - AI
  - XTU
abbrlink: 201806111
date: 2018-06-11 13:03:51
---

>写在前面

* 本文严禁转载，只限于学习[交流](mailto:nanzhouieATqq.com)。
* 课件分享在[这里](https://download.csdn.net/download/jave_f/10470736)了。
* 还有[人工智能标准化白皮书(2018版)](https://download.csdn.net/download/jave_f/10464580)也一并分享了。

## 绪论
### 人工智能的定义与发展
#### 定义

1. *一般解释*：人工智能就是用 **人工**的方法在 **机器（计算机）**上实现的智能，或称 **机器智能**；
2. *人工智能(学科)*：从学科的角度来说，人工智能是一门研究如何 **构造智能机器或智能系统**，使之能模拟、延伸、扩展人类智能的学科；
3. *人工智能(能力)*：从智能能力的角度来说，人工智能是智能机器所执行的通常 **与人类智能有关的智能行为**，如判断、推理、证明、识别、感知、理解、通信、设计、思考、规划、学习和问题求解等思维活动。

【**补充**】 2018年1月发布的[人工智能标准化白皮书](https://download.csdn.net/download/jave_f/10464580)上关于“人工智能的概念”有如下一段详尽描述（仅供参考）：

>2.1.2 人工智能的概念
>
>人工智能作为一门前沿交叉学科，其定义一直存有不同的观点：**《人工智能——一种现代方法》**中将已有的一些人工智能定义分为四类：像人一样思考的系统、像人一样行动的系统、理性地思考的系统、理性地行动的系统。**维基百科**上定义“人工智能就是机器展现出的智能”，即只要是某种机器，具有某种或某些“智能”的特征或表现，都应该算作“人工智能”。**大英百科全书**则限定人工智能是数字计算机或者数字计算机控制的机器人在执行智能生物体才有的一些任务上的能力。**百度百科**定义人工智能是“研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学”，将其视为计算机科学的一个分支，指出其研究包括机器人、语言识别、图像识别、自然语言处理和专家系统等。
>
>本白皮书认为，**人工智能是利用数字计算机或者数字计算机控制的机器模拟、延伸和扩展人的智能，感知环境、获取知识并使用知识获得最佳结果的理论、方法、技术及应用系统。**
>
>人工智能的定义对人工智能学科的基本思想和内容作出了解释，即围绕智能活动而构造的人工系统。人工智能是知识的工程，是机器模仿人类利用知识完成一定行为的过程。根据人工智能是否能真正实现推理、思考和解决问题，可以将人工智能分为弱人工智能和强人工智能。
>
>**弱人工智能**是指不能真正实现推理和解决问题的智能机器，这些机器表面看像是智能的，但是并不真正拥有智能，也不会有自主意识。迄今为止的人工智能系统都还是实现特定功能的专用智能，而不是像人类智能那样能够不断适应复杂的新环境并不断涌现出新的功能，因此都还是弱人工智能。目前的主流研究仍然集中于弱人工智能，并取得了显著进步，如语音识别、图像处理和物体分割、机器翻译等方面取得了重大突破，甚至可以接近或超越人类水平。
>
>**强人工智能**是指真正能思维的智能机器，并且认为这样的机器是有知觉的和自我意识的，这类机器可分为类人（机器的思考和推理类似人的思维）与非类人（机器产生了和人完全不一样的知觉和意识，使用和人完全不一样的推理方式）两大类。从一般意义来说，达到人类水平的、能够自适应地应对外界环境挑战的、具有自我意识的人工智能称为“通用人工智能”、“强人工智能”或“类人智能”。强人工智能不仅在哲学上存在巨大争论（涉及到思维与意识等根本问题的讨论），在技术上的研究也具有极大的挑战性。强人工智能当前鲜有进展，美国私营部门的专家及国家科技委员会比较支持的观点是，至少在未来几十年内难以实现。
>
>靠符号主义、连接主义、行为主义和统计主义这四个流派的经典路线就能设计制造出强人工智能吗？其中一个主流看法是：即使有更高性能的计算平台和更大规模的大数据助力，也还只是量变，不是质变，人类对自身智能的认识还处在初级阶段，在人类真正理解智能机理之前，不可能制造出强人工智能。理解大脑产生智能的机理是脑科学的终极性问题，绝大多数脑科学专家都认为这是一个数百年乃至数千年甚至永远都解决不了的问题。
>
>通向强人工智能还有一条“新”路线，这里称为“仿真主义”。这条新路线通过制造先进的大脑探测工具从结构上解析大脑，再利用工程技术手段构造出模仿大脑神经网络基元及结构的仿脑装置，最后通过环境刺激和交互训练仿真大脑实现类人智能，简言之，“先结构，后功能”。虽然这项工程也十分困难，但都是有可能在数十年内解决的工程技术问题，而不像“理解大脑”这个科学问题那样遥不可及。
>
>仿真主义可以说是符号主义、连接主义、行为主义和统计主义之后的第五个流派，和前四个流派有着千丝万缕的联系，也是前四个流派通向强人工智能的关键一环。经典计算机是数理逻辑的开关电路实现，采用冯•诺依曼体系结构，可以作为逻辑推理等专用智能的实现载体。但要靠经典计算机不可能实现强人工智能。要按仿真主义的路线“仿脑”，就必须设计制造全新的软硬件系统，这就是“类脑计算机”，或者更准确地称为“仿脑机”。“仿脑机”是“仿真工程”的标志性成果，也是“仿脑工程”通向强人工智能之路的重要里程碑。

#### 起源与发展

人工智能始于20世纪50年代，50多年来，人工智能走过了一条起伏和曲折的发展道路。回顾历史，可以按照不同时期的主要特征，将其产生与发展过程分为5个阶段。

1、孕育期（1956年前）

2、形成期（1956-1970年）

1956年夏，麦卡锡 (J.McCarthy，数学家、计算机专家)、明斯基(M.L.Minsky，哈佛大学数学家、神经学家)、洛切斯特(N.Lochester，IBM公司信息中心负责人)、香农(C.E.Shannon，贝尔实验室信息部数学家和信息学家)
邀请莫尔(T.more)、塞缪尔(A.L.Samuel) 、塞尔夫里奇(O.Selfridge)、索罗蒙夫(R.Solomonff)、纽厄尔(A.Newell)、西蒙(H.A.Simon)在 **美国达特茅斯(Dartmouth)大学**举办了长达历时两个月的研讨会。会上，麦卡锡正式使用“**人工智能AI**”这一术语。这是人类历史上首次第一次人工智能研讨会，**标志着人工智能学科的诞生**。

3、暗淡期（1966-1974年）

**失败的预言**给人工智能的声誉造成重大伤害
60年代初，西蒙预言：10年内计算机将成为世界冠军、将证明一个未发现的数学定理、将能谱写出具有优秀作曲家水平的乐曲、大多数心理学理论将在计算机上形成。

**挫折和困境**
* 在博弈方面：塞缪尔的下棋程序在与世界冠军对弈时，5局败了4局。
* 在定理证明方面：发现鲁宾逊归结法的能力有限。当用归结原理证明两个连续函数之和还是连续函数时，推了10万步也没证出结果。
* 在问题求解方面：对于不良结构，会产生 **组合爆炸**问题。
* 在机器翻译方面：发现并不那么简单，甚至会闹出笑话。例如，把“心有余而力不足”的英语句子翻译成俄语，再翻译回来时竟变成了“酒是好的，肉变质了”
* 在神经生理学方面：研究发现人脑有1011-12以上的神经元，在现有技术条件下用机器从结构上模拟人脑是根本不可能的。
* 在其它方面：人工智能也遇到了不少问题。在英国，剑桥大学的詹姆教授指责“人工智能研究不是骗局，也是庸人自扰” 。从此，形势急转直下，在全世界范围内人工智能研究陷入困境、落入低谷。

**Minsky的批评**
1969年 M. Minsky 和 S.Papert 在《感知机》一书中指出了感知机无法解决异或（XOR）问题的缺陷，并表示出对这方面研究的悲观态度，使得神经网络的研究从兴起期进入了停滞期。
该批评对人工智能的发展造成了重要的影响
* 在以后的二十年，感知机的研究方向被忽视
* 基于符号的知识表示成为主流
* 基于逻辑的推理成为主要研究方向

**当时的人工智能存在三个方面的局限性**
* 知识局限性：早期开发的人工智能程序中包含了太少的主题知识，甚至没有知识，而且只采用简单的句法处理。
* 解法局限性：求解方法和步骤的局限性使得设计的人工智能程序在实际上无法求得问题的解答，或者只能得到简单问题的解答，而这种简单问题并不需要人工智能的参与。
* 结构局限性：用于产生智能行为的人工智能系统或程序在一些基本结构上严重局限，如没有考虑不良结构，无法处理组合爆炸问题，因而只能用于解决比较简单的问题，影响到人工智能系统的推广应用。

4、知识应用期（ 1970-1988年）

5、集成发展期（1986年至今）

人工智能具体的发展历程图示如下：
![](https://i.loli.net/2019/02/23/5c7168e330d87.jpg)

这两年人工智能得到了突飞猛进的发展，实现这种发展的基本条件有三个：
* **大数据的积累**
* **计算能力的提升**
* **理论算法的革新**

### 各种认知观

#### 目前人工智能主要有以下三个学派：

* **符号主义**（Symbolicism）: 基于物理符号系统假设和有限合理性原理（逻辑）

符号主义观点认为：**智能的基础是知识**，其核心是知识表示和知识推理；知识可用符号表示，也可用符号进行推理，因而可以建立基于知识的人类智能和机器智能的统一的理论体系。

* **连接主义**（Connectionism）: 基于神经网络及其间的连接机制与学习算法（仿生）

连接主义观点认为：**思维的基元是神经元**，而不是符号；思维过程是神经元的联结活动过程，而不是符号运算过程；反对符号主义关于物理符号系统的假设。

* **行为主义**（Actionism）: 基于控制论及感知—动作型控制系统（进化）

行为主义观点认为：**智能取决于感知和行动**，提出了智能行为的“感知—动作”模型；**智能不需要知识、不需要表示、不需要推理**；人工智能可以像人类智能那样逐步进化。

此外，还有一种由[钟义信](https://baike.baidu.com/item/%E9%92%9F%E4%B9%89%E4%BF%A1/7371623?fr=aladdin)院士提出的一种认知学派：

* **机制主义**（mechanism）：结构（连接）主义、功能（符号）主义、行为主义的和谐统一。

#### 几种学派各自不足之处：

* **符号主义的不足**(功能模拟法/认知学观点)
    - 在用符号表示知识的概念时，有效性很大程度上取决于符号表示的正确性和准确性
    - 将知识概念转换成符号时，可能丢失一些重要信息
    - 难于对含噪信息、不确定性信息和不完全性信息进行处理

* **连接主义的不足**(结构模拟法/生物学观点)
    - 由于大脑的生理结构和工作机理还远未搞清楚，因而现在只能对人脑的局部进行模拟或进行近似模拟
    - 不适合模拟人的逻辑思维过程
    - 受大规模人工神经网络制造的制约
    - 尚不能满足人脑完全模拟的要求

* **行为主义的不足**
    - 难以获得高级智能控制行为

### 研究目标与内容

#### 研究目标

远期目标：构造出可以实现人类思维活动和智力功能的智能系统。
近期目标：使现有的计算机更聪明更有用，使它不仅能够进行一般的数值计算和非数值信息的处理，而且能够运用知识去处理问题，能够模拟人类的智能行为。

#### 研究的基本内容

1、认知建模
认知：可一般地认为是和情感、动机、意志相对应的理智或认识过程，或者是为了一定的目的，在一定的心理结构中进行的信息加工过程。

2、知识表示：基础

3、知识推理：实现问题求解

4、知识应用：目的

> 知识表示、知识推理、知识应用是传统人工智能的三大核心研究内容。

5、**机器感知**：就是要让计算机具有类似于人的感知能力，如视觉、听觉、触觉、嗅觉、味觉……，是机器获取外部信息的基本途径
* 相当于智能系统的输入部分
* 机器视觉（或叫计算机视觉）：就是给计算机配上能看的视觉器官，如摄像机等，使它可以识别并理解文字、图像、景物等
* 机器听觉（或叫计算机听觉）：就是给计算配上能听的听觉器官，如话筒等，使计算机能够识别并理解语言、声音等。
* 模式识别：对客体的识别与分类
* 自然语言理解：实现人机对话
* 机器翻译

6、**机器思维**：
机器思维是让计算机能够对感知到的外界信息和自己产生的内部信息进行思维性加工，包括逻辑思维、形象思维和灵感思维，涉及信息的表示，组织，积累，管理，搜索，推理等过程。

7、**机器学习**：
* 让计算机能够像人那样自动地获取新知识，并在实践中不断地完善自我和增强能力。
* 是机器获取智能的途径
* 学习是一个有特定目的的知识获取过程，学习的本质是对信息的理解与应用

8、**机器行为**：
* 让计算机能够具有像人那样地行动和表达能力，如走、跑、拿、说、唱、写画等。
* 相当于智能系统的输出部分

9、**智能系统构建**
* 无论是人工智能的近期目标还是远期目标，都需要建立智能系统或构造智能机器
* 需要开展对系统模型、构造技术、构造工具及语言环境等研究

### 应用领域
问题求解、机器学习、自然语言理解、专家系统、模式识别、计算机视觉、机器人学、博弈、计算智能、人工生命、自动定理证明、自动程序设计、智能控制、智能检索、智能调度与指挥、智能决策支持系统、人工神经网络、数据挖掘与知识发现......

### 课后习题
1-1 什么是人工智能？是从科学与能力两方面加以说明。
1-3 在人工智能的发展过程中，有哪些思想和思潮起到了重要作用？
1-5 人工智能有哪些学派？他们的认知观是什么？现在这些学派的关系如何？
1-9 人工智能的基本研究方法有哪些类？
1-10 人工智能的主要研究和应用领域是什么？其中，哪些是新的研究热点？

## 知识表示与推理

### 知识表示方法

>知识的一般概念

知识是人们在改造客观世界的实践中积累起来的 **认识**和 **经验**。
其中，**认识**与 **经验**可以这样定义：
* 认识：包括对事物现象、本质、属性、状态、联系等的认识
* 经验：包括解决问题的微观方法和宏观方法
    - 微观方法：如步骤、操作、规则、过程、技巧等
    - 宏观方法：如战略、战术、计谋、策略等

>人工智能系统中的知识

一个智能程序高水平的运行需要有关的 **事实知识**、 **规则知识**、 **控制知识**和 **元知识**。

* 事实知识 ：是有关问题环境的一些事物的知识，常以“…是…”的形式出现。
    - 如事物的分类、属性、事物间关系、科学事实、客观事实等。
    - 事实是静态的为人们共享的可公开获得的公认的知识，在知识库中属低层的知识，如：雪是白色的、鸟有翅膀、张三李四是好朋友、这辆车是张三的……
* 规则知识 ：是有关问题中与事物的行动、动作相联系的因果关系知识，是动态的，常以“如果…那么…” 形式出现。
* 控制知识 ：是有关问题的求解步骤、技巧的知识，告诉人们怎么做一件事，也包括当有多个动作同时被激活时应选哪一个动作来执行的知识。控制知识常与程序结合在一起出现，如一个问题求解的算法可以看做是一种知识表示。
* 元知识 ：是有关知识的知识，是知识库中的高层知识。包括怎样使用规则、解释规则、校验规则、解释程序结构等知识。

元知识与控制知识是有重迭的，对一个大的程序来说，以元知识或说元规则形式体现控制知识更为方便，因为元知识存于知识库中，而控制知识常与程序结合在一起出现，从而不容易修改。

>知识表示

研究用机器表示知识的可行性、有效性的一般方法，是一种数据结构与控制结构的统一体，既考虑知识的存储又考虑知识的使用。

知识表示的要求：
* 表示能力：能否正确、有效地表示问题。包括：表范围的广泛性、领域知识表示的高效性、对非确定性知识表示的支持程度；
* 可利用性：可利用这些知识进行有效推理。包括：对推理的适应性，对高效算法的支持程度；
* 可实现性：要便于计算机直接对其进行处理；
* 可组织性：可以按某种方式把知识组织成某种知识结构；
* 可维护性：便于对知识的增、删、改等操作；
* 自然性：符合人们的日常习惯；
* 可理解性：知识应易读、易懂、易获取等。

#### 状态空间法

状态空间法是一种 **基于解答空间的问题表示和求解方法**，它是以“**状态**（state）”和“**算符**（operator）”为基础的，它是人工智能中最基本的 **形式化方法**。
由于状态空间法需要扩展过多的节点，容易出现“**组合爆炸**”，因而 **只适用于表示比较简单的问题**。

>状态空间法的三要素：

1. **状态**（state）：描述某类不同事物间的差别而引入的一组最少变量 `q0，q1，…，qn`的有序集合，是表示问题解法中每一步问题状况的数据结构。有序集合中每个元素qi（i= 0,1,...,n）为集合的分量，称为状态变量。给定每个分量的一组值就得到一个具体的状态。
2. **算符**（operator）：使问题从一种状态变化为另一种状态的手段称为操作符或算符。
3. **问题的状态空间****：即解答空间，也就是一个表示该问题全部可能状态及其关系的图。它是以状态和算符为基础来表示和求解问题的。它包含三种说明的集合，即S：所有可能的问题初始状态集合、F：操作符集合、G：目标状态集合。可将状态空间记为三元状态`（S，F，G）`。

---

【例子】
**猴子和香蕉问题**：在一个房间内有一只猴子、一个箱子和一束香蕉。香蕉挂在天花板下方，但猴子的高度不足以碰到它。那么这只猴子怎样才能摘到香蕉呢?
![](https://i.loli.net/2019/02/23/5c71689ea4bc5.jpg)

**解题过程**
用一个四元表列`(W，x，Y，z)`来表示这个问题状态空间
其中W：猴子的水平位置；x：当猴子在箱子顶上时取1；否则取0；Y：箱子的水平位置；z：当猴子摘到香蕉时取1；否则取0。
则可见初始状态为`(a,0,b,0)`，目标状态为`(c,1,c,1)`

这个问题的算符如下：
`goto(U)`表示猴子走到水平位置U；`pushbox(V)`表示猴子把箱子推到水平位置V；`climbbox`表示猴子爬上箱顶；`grasp`表示猴子摘到香蕉。

由初始状态变换为目标状态的操作序列为：
    Step1: `goto(b) `
    Step2: `pushbox(c) `
    Step3: `climbbox `
    Step4: `grasp `
![](https://i.loli.net/2019/02/23/5c71698de93c6.jpg)

---

#### 问题归约法

> 问题规约（Problem Reduction）：

* 另外一种 **基于状态空间**的问题描述与求解方法；
* 已知问题的描述，通过一系列 **变换** 把此问题变为一个 **子问题集合**；
* 这些子问题的解可以直接得到（**本原问题**），从而解决了初始问题。

> 问题归约的组成部分：

* 一个初始问题描述；
* 一套把问题变换为子问题的 **操作符**；
* 一套本原问题描述。(本原问题:不能再分解或变换且直接可解的子问题)。

> 问题归约的 **实质**：

* 从目标（要解决的问题）出发 **逆向推理**，建立子问题以及子问题的子问题，直到 **最后把初始问题归约为一个本原问题集合**。

> 问题归约法举例：

---

【例子】
**汉诺塔问题**(Hanoi):规定每次移动一个盘子、且总个过程中大盘在下小盘在上、目标是将盘子从柱子1移到柱子3。
![](https://i.loli.net/2019/02/23/5c716ae5a04f8.jpg)

**解题过程**

原始问题可以归约为下列3个子问题：
![](https://i.loli.net/2019/02/23/5c716ae5ec730.jpg)

规约过程：
![](https://i.loli.net/2019/02/23/5c716ae5c0158.jpg)

归约图示：
![](https://i.loli.net/2019/02/23/5c716ae5f07cb.jpg)

---

>与或图表示

用一个类似于图的结构来表示,把问题归约为后继问题的替换集合。
* 与图：把一个复杂问题分解为若干个较为简单的子问题，形成“与”树。
![](https://i.loli.net/2019/02/23/5c716d990f22f.jpg)

* 或图：把原问题变换为若干个较为容易求解的新问题，形成“或”树。
![](https://i.loli.net/2019/02/23/5c716d98ec484.jpg)

#### 谓词逻辑法
谓词逻辑法采用谓词合式公式和一阶谓词演算将要解决的问题变成一个有待证明的问题，然后利用消解定理和消解反演来证明一个新语句是从已知的正确语句中导出的，从而证明这个新语句也是正确的。
谓词逻辑是一种 **形式语言**，能够将数学中的逻辑论证符号化，谓词逻辑经常与其他表示方法混合使用，**可以表示比较复杂的问题**。

##### 谓词演算

>语法和语义

* 基本符号：谓词符号、变量符号、函数符号、常量符号、括号和逗号
* 原子公式由若干谓词符号和项组成

>连词和量词

* 连词
合取、析取、蕴涵、非、双条件

* 量词
全称量词、存在量词

>谓词公式

* 原子谓词公式
由谓词符号和若干项组成的谓词演算

* 分子谓词公式
可以用 **连词**把原子谓词公式组成复合谓词公式，并把它叫做分子谓词公式
通常把合式公式叫做谓词公式。在谓词演算中合式公式的递归定义如下：
![](https://i.loli.net/2019/02/23/5c716d99498e9.jpg)

>合式公式的性质

![](https://i.loli.net/2019/02/23/5c716d9957c2b.jpg)

##### 置换与合一

>置换

置换是用变元、常量、函数来替换变元，使该变元不在公式中出现，形如`{t1/x1, t2/x2,...，tn/xn}`的有限集合，其中：
* `t1，t2，...，tn`是项；
* `x1，x2，...，xn`是互不相同的变元；
* `ti/xi`表示用ti项替换变元`xi`，不允许`ti`和`xi`相同，也不允许变元`xi`循环地出现在另一个tj中。

推理规则：用合式公式的集合产生新的合式公式
![](https://i.loli.net/2019/02/23/5c716d991549a.jpg)

置换是 **可结合的**；
用`s1s2`表示两个置换s1和s2的合成，L表示一个表达式，则有`(Ls1)s2 = L(s1s2)`以及`(s1s2)s3 = s1(s2s3)`，即用s1和s2相继作用于表达式L是与用`s1s2`作用于L一样的。
一般说来，置换是 **不可交换的**，即`s1s2 ≠ s2s1`。

>合一

寻找项对变量的置换，以使两表达式一致，叫做合一。
如果一个置换s作用于表达式集合`{Ei}`的每个元素，则用`{Ei}s`来表示置换的集。称表达式{Ei}是可合一的，如果存在一个置换s使得：`E1s = E2s =  E3s =……`，那么，称此s为`{Ei}`的合一者，因为s的作用是使集合`{Ei}`成为单一形式。
例如：设有公式集`E={ P( x, y, f(y)),  P( a, g(x), z) }`，则`s={a/x, g(a)/y, f(g(a))/z}`是它的一个合一。


#### 语义网路法

语义网络是通过概念及其语义关系来表达知识一种网络图，是一种 **结构化表示方法**。
从图论的观点看，语义网络是一个“带标识的有向图”，它由 **节点**和 **弧线或链线**组成。**节点代表实体、概念、情况等**，**弧线代表节点间的关系**，必须带标识。
语义网络的解答是一个经过推理和匹配而得到的具有明确结果的新的语义网路，扩展后可以表示更复杂的问题。

语义网络中最基本的语义单元称为语义基元，可用三元组表示为：(结点1，弧，结点2)。

> 二元语义网络的表示

例如：用语义网络表示：李新的汽车的款式是“捷达”、银灰色；王红的汽车的款式是“凯越”、红色；李新和王红的汽车均属于具体概念,可增加“汽车” 这个抽象概念。
![](https://i.loli.net/2019/02/23/5c716d993cab5.jpg)

> 多元语义网络的表示

* 增加情况和动作节点；
* 增加事件节点；
* 连接词和量词的表示；
* ......


#### 其他方法

* 框架表示法
这是一种 **结构化方法**；
框架理论是明斯基于1975年作为理解视觉、自然语言对话及其它复杂行为的一种基础提出来的；
框架理论认为，人们对现实世界中各种事物的认识都是以一种类似于框架的结构存储在记忆中的。当遇到一个新事物时，就从记忆中找出一个合适的框架，并根据新的情况对其细节加以修改、补充，从而形成对这个新事物的认识。

框架网络：
![](https://i.loli.net/2019/02/23/5c716d9947a4f.jpg)

框架结构：
![](https://i.loli.net/2019/02/23/5c716d9934fbb.jpg)

* 每个框架都有框架名，代表某一类对象
* 一个框架由若干个槽（项目）组成，用于表示对象的某个方面的属性
* 有时一个槽（属性）还要从不同的侧面来描述，每个侧面可具有一个或多个值。
注意：框架中的槽与侧面可任意定义，也可以是另一框架，形成框架网络系统。

* 剧本表示法(ppt-6)
* 过程表示法(ppt-6)
* ......

### 确定性推理

#### 推理的基本概念

>推理方法及其分类

1. 按推理的逻辑基础分：演绎推理，归纳推理，类比归纳推理
2. 按推理过程所用知识的确定性分：确定性推理、 不确定性推理
3. 按推理过程推出的结论是否单调增加分：单调推理、非单调推理
4. 按推理过程是否利用问题的启发性知识分：启发式推理、非启发式推理

>推理的控制策略及其分类

推理的控制策略是指如何使用领域知识使推理过程尽快达到目标的策略。

* 推理策略
    - **推理方向控制策略**可分为
        + 正向推理
        + 逆向推理
        + 混合推理
        + 双向推理
    - **求解策略**：是指仅求一个解，还是求所有解或最优解等。
    - **限制策略**：是指对推理的深度、宽度、时间、空间等进行的限制。
    - **冲突消解策略**：是指当推理过程有多条知识可用时，如何从这多条可用知识中选出一条最佳知识用于推理的策略。
* 搜索策略（下面会详述）

#### 搜索策略

* 按是否使用启发式信息：
    - 盲目搜索：按预定的控制策略进行搜索，在搜索过程中获得的中间信息并不改变控制策略。
    - 启发式搜索：在搜索中加入了与问题有关的启发性信息，用于指导搜索朝着最有希望的方向前进，加速问题的求解过程并找到最优解。
* 按问题的表示方式：
    - 状态空间搜索：用指用状态空间法来表示问题所进行的搜索
    - 与或树搜索：用指用问题归约法来表示问题所进行的搜索

##### 状态空间的搜索策略

* 状态空间的盲目搜索
    - 广度优先搜索
    - 深度优先搜索
    - 代价树搜索
* 状态空间的启发式搜索
    - 启发性信息和估价函数
    - A算法和A*算法
* 基本思想
    - 先把问题的初始状态作为当前扩展节点对其进行扩展，生成一组子节点。
    - 然后检查问题的目标状态是否出现在这些子节点中。若出现，则搜索成功，找到了问题的解；若没出现，则再 **按照某种搜索策略**从已生成的子节点中选择一个节点作为当前扩展节点。
    - 重复上述过程，直到目标状态出现在子节点中或者没有可供操作的节点为止。
    - 所谓对一个节点进行“扩展”是指对该节点用某个可用操作进行作用，生成该节点的一组子节点。
* 数据结构和符号约定
    - **OPEN表**：未扩展节点表，用于存放刚生成节点
    - **CLOSED表**：已扩展节点表，用于存放已经扩展或将要扩展的节点
    - S：用表示问题的初始状态
    - G：表示搜索过程所得到的搜索图
    - M：表示当前扩展节点新生成的且不为自己先辈的子节点集

*各种搜索策略的主要区别在于对OPEN表中节点的排列顺序不同。*例如，广度优先搜索把先生成的子节点排在前面，而深度优先搜索则把后生成的子节点排在前面。

>广度优先搜索算法流程：

1. 把初始节点S放入OPEN表中；
2. 如果OPEN表为空，则问题无解，失败退出；
3. 把OPEN表的第一个节点取出放入CLOSED表，并记该节点为n；
4. 考察节点n是否为目标节点。若是，则得到问题的解，成功退出；
5. 若节点n不可扩展，则转第(2)步；
6. 扩展节点n，将其子节点放入OPEN表的 **尾部**，并为每一个子节点设置指向父节点的指针，然后转第(2)步。

以八数码问题为例，得到下面这个广度优先搜索树：
![](https://i.loli.net/2019/02/24/5c71700f35a3f.jpg)

在上述广度优先算法中需要注意两个问题：
* 对于任意一个可扩展的节点，总是按照固定的操作符的顺序对其进行扩展（空格左移、上移、右移、下移）。
* 在对任一节点进行扩展的时候，如果所得的某个子节点（状态）前面已经出现过，则立即将其放弃，不再重复画出（不送入OPEN表）。
因此，广度优先搜索的本质是，以初始节点为根节点，在状态空间图中按照广度优先的原则，生成一棵搜索树。

广度优先搜索的优缺点：
* 优点
    - 只要问题有解，用广度优先搜索总可以得到解，而且得到的是路径最短的解。
* 缺点
    - 广度优先搜索盲目性较大，当目标节点距初始节点较远时将会产生许多无用节点，搜索效率低。

>深度优先搜索算法流程：

1. 把初始节点S放入OPEN表中；
2. 如果OPEN表为空，则问题无解 ，失败退出；
3. 把OPEN表的第一个节点取出放入CLOSED表，并记该节点为n；
4. 考察节点n是否为目标节点。若是，则得到问题的解，成功退出；
5. 若节点n不可扩展，则转第(2)步；
6. 扩展节点n，将其子节点放入OPEN表的 **首部**，并为每一个子节点设置 指向父节点的指针，然后转第(2)步。

在深度优先搜索中，搜索一旦进入某个分支，就将沿着该分支一直向下搜索。如果目标节点恰好在此分支上，则可较快地得到解。但是，如果目标节点不在此分支上，而该分支又是一个无穷分支，则就不可能得到解。所以深度优先搜索是不完备的，即使问题有解，它也不一定能求得解。
因此，为了防止搜索过程沿着无益的路径扩展下去，往往给出一个节点扩展的最大深度，即 **深度界限**。当搜索深度达到了深度界限而仍未出现目标节点时，就换一个分支进行搜索。

有界深度优先搜索的特点：

* 从某种意义上讲，有界深度优先搜索具有一定的启发性；
* 如果问题有解，且其路径长度≤dm，则上述搜索过程一定能求得解。
* 但是若解的路径长度> dm,则上述搜索过程就得不到解。。
* 这说明在有界深度优先搜索中，深度界限的选择是很重要的，但是要恰当地给出dm的值是比较困难的。
* 即使能求出解，它也不一定是最优解。

>代价树搜索

考虑边的代价的搜索方法，代价树搜索的目的是为了找到一条代价最小的解路径。代价树搜索方法包括：
* 代价树的广度优先搜索
* 代价树的深度优先搜索

>启发式信息与代价函数

采用问题自身的特性信息，以指导搜索朝着最有希望的方向前进。
启发性信息是指那种与具体问题求解过程有关的，并可指导搜索过程朝着最有希望方向前进的控制信息。启发信息的启发能力越强，扩展的无用结点越少。

启发性信息的种类
* 有效地帮助确定扩展节点的信息；
* 有效的帮助决定哪些后继节点应被生成的信息；
* 能决定在扩展一个节点时哪些节点应从搜索树上删除的信息。

估价函数的一般形式为：`f(x) = g(x)+h(x)`，其中`g(x)`表示从初始节点S0到节点x的代价；`h(x)`是从节点x到目标节点Sg的最优路径的代价的估计，它体现了问题的启发性信息，`h(x)`称为启发函数。

>A算法与A*算法

A算法：在图搜索算法中，如果能在搜索的每一步都利用估价函数`f(n)=g(n)+h(n)`对OPEN表中的节点进行排序，则该搜索算法为A算法。

A算法的类型
可根据搜索过程中选择扩展节点的范围，将启发式搜索算法分为：
* 全局择优搜索算法： 从OPEN表的所有节点中选择一个估价函数值最小的一个进行扩展。
* 局部择优搜索算法：仅从刚生成的子节点中选择一个估价函数值最小的一个进行扩展。

A*算法是对A算法的估价函数`f(n)=g(n)+h(n)`加上某些限制后得到的一种启发式搜索算法。

假设`f*(n)`是从初始节点出发经过节点n达到目标节点的最小代价，估价函数`f(n)`是对`f*(n)`的 **估计值**。且`f*(n)=g*(n)+h*(n)`，`g*(n)`是从初始节点S0到节点n的最小代价。`h*(n)`是从节点n到目标节点的最小代价，**若有多个目标节点，则为其中最小的一个**。

A*算法对A算法（全局择优的启发式搜索算法）中的`g(n)`和`h(n)`分别提出如下限制：

* 第一，`g(n)`是对最小代价`g*(n)`的估计，且`g(n)>0`；
* 第二，`h(n)`是最小代价`h*(n)`的下界，即对任意节点n均有`h(n)≤h*(n)`。

即：满足上述两条限制的A算法称为A*算法。


##### 与/或树的搜索策略(ppt-9~10)

1、 与/或树的一般搜索过程

```
(1) 把原始问题作为初始节点S0，并把它作为当前节点；
(2) 应用分解或等价变换操作对当前节点进行扩展；
(3) 为每个子节点设置指向父节点的指针；
(4) 选择合适的子节点作为当前节点，反复执行第(2)步和第(3)步，在此期间需要多次调用可解标记过程或不可解标记过程，直到初始节点被标记为可解节点或不可解节点为止。
```

2、 与/或树的广度优先搜索

```
(1)把初始节点S0放入OPEN表中；
(2)把OPEN表的第一个节点取出放入CLOSED表，并记该节点为n；
(3)如果节点n可扩展，则做下列工作：
    ① 扩展节点n，将其子节点放入OPEN表的尾部，并为每一个子节点设置指向父节点的指针；
    ② 考察这些子节点中有否终止节点。若有，则标记这些终止节点为可解节点，并用可解标记过程对其父节点及先辈节点中的可解解节点进行标记。如果初始解节点S0能够被标记为可解节点，就得到了解树，搜索成功，退出搜索过程；如果不能确定S0为可解节点，则从OPEN表中删去具有可解先辈的节点。
    ③ 转第(2)步。
(4) 如果节点n不可扩展，则作下列工作：
    ① 标记节点n为不可解节点；
    ② 应用不可解标记过程对节点n的先辈中不可解解的节点进行标记。如果初始解节点S0也被标记为不可解节点，则搜索失败，表明原始问题无解，退出搜索过程；如果不能确定S0为不可解节点，则从Open表中删去具有不可解先辈的节点。
    ③ 转第(2)步。
```

---

【例子】 设有下图所示的与/或树，节点按标注顺序进行扩展，其中标有t1、t2、t3的节点是终止节点，A、B、C为不可解的端节点。
![](https://i.loli.net/2019/02/24/5c71700dab32a.jpg)

本例中与/或树的广度优先搜索过程：

(1) 先扩展1号节点，生成2号节点和3号节点。
(2) 扩展2号节点，生成A节点和4号节点。
(3) 扩展3号节点，生成t1节点和5号节点。由于t1为终止节点，则标记它为可解节点，并应用可解标记过程，不能确定3号节点是否可节。
(4)  扩展节点A，由于A是端节点，因此不可扩展。调用不可解标记过程。
(5) 扩展4号节点，生成t2节点和B节点。由于t2为终止节点，标记为可解节点，应用可解标记过程，可标记2号节点为可解，但不能标记1号节点为可解。
(6) 扩展5号节点，生成t3节点和C节点。由于t3为终止节点，标记它为可解节点，应用可解标记过程，可标记1号节点为可解节点。
(7) 搜索成功，得到由1、2、3、4、5号节点和t1、t2、t3节点构成的解树。

---

3、 与/或树的深度优先搜索

```
(1)把初始节点S0放入OPEN表中；
(2)把OPEN表第一个节点取出放入CLOSED表，并记该节点为n；
与/或树的深度优先搜索算法如下：
(3)如果节点n的深度等于dm，则转第(5)步的第①点；
(4)如果节点n可扩展，则做下列工作：
    ① 扩展节点n，将其子节点放入OPEN表的首部，并为每一个子节点设置指向父节点的指针；
    ② 考察这些子节点中是否有终止节点。若有，则标记这些终止节点为可解节点，并用可解标记过程对其父节点及先辈节点中的可解解节点进行标记。如果初始解节点S0能够被标记为可解节点，就得到了解树，搜索成功；如果不能确定S0为可解节点，则从OPEN表中删去具有可解先辈的节点。
    ③ 转第(2)步。
(5)如果节点n不可扩展，则作下列工作：
    ① 标记节点n为不可解节点；
    ② 应用不可解标记过程对节点n的先辈中不可解解的节点进行标记。如果初始解节点S0也被标记为不可解节点，则搜索失败，表明原始问题无解，退出搜索过程；如果不能确定S0为不可解节点，则从Open表中删去具有不可解先辈的节点。
    ③ 转第(2)步。
```

4、 与/或树的启发式搜索

```
(1) 把初始节点S0放入OPEN表中；
(2) 求出希望树T，即根据当前搜索树中节点的代价h求出以S0为根的希望树T；
(3) 依次在OPEN表中取出T的端节点放入CLOSED表，并记该节点为n；节点n有三种不同情况：
    ①n为终止节点，
    ②n不是终止节点，但可扩展，
    ③n不是终止节点，且不可扩展，
对三种情况分别进行步骤(4) (5) (6)的操作过程；
(4)如果节点n为终止节点，则：
    ① 标记节点n为可解节点；
    ② 在T上应用可解标记过程，对n的先辈节点中的所有可解解节点进行标记；
    ③ 如果初始解节点S0能够被标记为可解节点，则T就是最优解树，成功退出；
    ④ 否则，从OPEN表中删去具有可解先辈的所有节点。
    ⑤ 转第(2)步。
(5) 如果节点n不是终止节点，但可扩展，则：
    ① 扩展节点n，生成n的所有子节点；
    ② 把这些子节点都放入OPEN表中，并为每一个子节点设置指向父节点n的指针；
    ③ 计算这些子节点及其先辈节点的h值；
    ④ 转第(2)步。
(6) 如果节点n不是终止节点，且不可扩展，则：
    ① 标记节点n为不可解节点；
    ② 在T上应用不可解标记过程，对n的先辈节点中的所有不可解解节点进行标记；
    ③ 如果初始解节点S0能够被标记为不可解节点，则问题无解，失败退出；
    ④ 否则，从OPEN表中删去具有不可解先辈的所有节点。
    ⑤ 转第(2)步。
```
5、 博弈树的启发式搜索
6、 α-β剪枝技术

>搜索的完备性与效率

**完备性**
* 对于一类 **可解的问题**和一个搜索过程，如果运用该搜索过程一定能求得该类问题的解，则称该搜索过程为 **完备**的，否则为不完备的。
* 完备的搜索过程称为“搜索算法”。不完备的搜索过程不是算法，称为“过程”。
* 广度优先搜索、代价树的广度优先搜索、改进后的有界深度优先搜索以及A*算法都是完备的搜索过程，其它搜索过程都是不完备的。

**搜索效率**
* 一个搜索过程的搜索效率不仅取决于过程自身的启发能力，而且还与被解问题的有关属性等多种因素有关。
* 为了比较求解同一问题的不同搜索方法的效率，常用以下两种指标来衡量：
    - **外显率**
    - **有效分支因数**

其中，外显率定义为：`P=L/T`；L为从初始节点到目标节点的路径长度；T为整个搜索过程中所生成的节点总数。
外显率反映了搜索过程中从初始节点向目标节点前进时 **搜索区域的宽度**。当`T=L`时，`P=1`，表示搜索过程中每次只生成一个节点，它恰好是解路径上的节点，搜索效率最高。P越小表示搜索时产生的无用节点愈多，搜索效率愈低。

有效分枝因数B定义为：`B+B^2+…+B^L=T`；B是有效分枝因数，它表示在整个搜索过程中 **每个节点平均生成的子节点数目**；L为从初始节点到目标节点的路径长度；T为整个搜索过程中所生成的节点总数。当`B＝1`时，`L=T`，此时所生成的节点数最少，搜索效率最高。


#### 自然演绎推理
从一组已知为真的事实出发，直接运用经典逻辑中的推理规则推出结论的过程称为自然演绎推理。
自然演绎推理最基本的推理规则是三段论推理，它包括：
![](https://i.loli.net/2019/02/24/5c71700f34e3a.jpg)

---

【例子】 设已知如下事实：
(1) 只要是需要编程序的课，王程都喜欢。
(2) 所有的程序设计语言课都是需要编程序的课。
(3) C是一门程序设计语言课。
求证：王程喜欢C这门课。

证明：
第一步，首先定义谓词
    `Prog(x)`：x是需要编程序的课。
    `Like(x, y)`: x喜欢y。
    `Lang(x)`: x是一门程序设计语言课
第二步，把已知事实及待求解问题用谓词公式表示如下：
    `Prog(x)→Like(Wang , x)`
    `(∀x)( Lang(x)→Prog(x))`
    `Lang(C)`
第三步，应用推理规则进行推理：
    `Lang(y)→Prog(y)`                                    全称固化
    `Lang(C)，Lang(y)→Prog(y) ⇒ Prog(C)`                 假言推理 {C/y}
    `Prog(C),  Prog(x)→Like(Wang , x) ⇒ Like(Wang , C)`  假言推理  {C/x}
因此，王程喜欢C这门课。

---

##### 注意避免以下两类错误：
* 肯定后件的错误：当`P→Q`为真时，希望通过肯定后件Q为真来推出前件P为真，这是不允许的。
* 否定前件的错误：当`P→Q`为真时，希望通过否定前件P来推出后件Q为假，这也是不允许的。

##### 自然演绎推理的优缺点
* 优点
    - 定理证明过程自然，易于理解，并且有丰富的推理规则可用。
* 缺点
    - 是容易产生知识爆炸，推理过程中得到的中间结论一般按指数规律递增，对于复杂问题的推理不利，甚至难以实现。


#### 消解演绎推理

一种基于 **鲁滨逊（Robinson）消解原理**的机器推理技术。鲁滨逊消解原理亦称为消解原理，是鲁滨逊于1965年在海伯伦（Herbrand）理论的基础上提出的一种基于逻辑的“反证法”。

>在人工智能中，几乎所有的问题都可以转化为一个定理证明问题。定理证明的实质，就是要对前提P和结论Q，证明`P→Q`永真。
>而要证明`P→Q`永真，就是要证明`P→Q`在任何一个非空的个体域上都是永真的。这将是非常困难的，甚至是不可实现的。

**鲁滨逊消解原理**把永真性的证明转化为关于 **不可满足性**的证明。即：要证明`P→Q`永真，只需证明`P∧¬Q`不可满足。（`¬(P→Q) ⇔ ¬(¬P∨Q) ⇔ P∧¬Q`）

##### 子句集及其化简

>鲁滨逊消解原理是在子句集的基础上讨论问题的。因此，讨论消解演绎推理之前，需要先讨论子句集的有关概念。

* 原子谓词公式及其否定统称为 **文字**。例如: P(x)、Q(x)、¬ P(x)、 ¬ Q(x)等都是文字。
* 任何文字的析取式称为 **子句**。例如，P(x)∨Q(x)，P(x，f(x))∨Q(x，g(x))都是子句。
* 不含任何文字的子句称为 **空子句**。
    - 由于空子句不含有任何文字，也就不能被任何解释所满足，因此 **空子句是永假的**，不可满足的。
    - 空子句一般被记为NIL。
* 由子句或空子句所构成的集合称为 **子句集**。
    - 在子句集中，子句之间是 **合取关系**；
    - 子句集中的变元受 **全称量词**的约束；
    - 任何谓词公式都可通过等价关系及推理规则化为相应的子句集。

把谓词公式化成子句集的步骤
![](https://i.loli.net/2019/02/24/5c71701202615.jpg)

子句集的意义
在上述化简过程中，由于在消去存在量词时所用的Skolem函数可以不同，因此化简后的标准子句集是不唯一的。因此，当原谓词公式为非永假时，它与其标准子句集并不等价。但当原谓词公式为永假（或不可满足）时，其标准子句集则一定是永假的，即Skolem化并不影响原谓词公式的永假性。

不可满足性
对于任意论域中的任意一个解释，S中的子句不能同时取得真值T。

>定理：设有谓词公式F，其子句集为S，则F不可满足的充要条件是S不可满足。

* 由此定理可知，要证明一个谓词公式是不可满足的，只要证明其相应的标准子句集是不可满足的就可以了。
* 由于子句集中的子句之间是合取关系，**子句集中只要有一个子句为不可满足，则整个子句集就是不可满足的**。
* 空子句是不可满足的。因此，**一个子句集中如果包含有空子句，则此子句集就一定是不可满足的**。
* 这个定理是 **鲁滨逊消解原理的主要依据**。

##### 鲁滨逊消解原理

鲁滨逊消解原理的基本思想
* 首先把欲证明问题的 **结论否定**，并加入子句集，得到一个扩充的子句集S'；
* 然后设法检验子句集S'是否含有空子句，若含有空子句，则表明S'是不可满足的；若不含有空子句，则继续使用消解法，在子句集中选择合适的子句进行消解，**直至导出空子句或不能继续消解为止**。

鲁滨逊消解原理包括
* 命题逻辑的消解
* 谓词逻辑的消解

>命题逻辑的消解

消解推理的核心是求两个子句的 **消解式**。
* 设C1和C2是子句集中的任意两个子句，如果C1中的文字L1与C2中的文字L2 **互补**，那么可从C1和C2中分别消去L1和L2，并将C1和C2中余下的部分按析取关系构成一个新的子句C12，则称这一过程为 **消解**，称C12为C1和C2的 **消解式**，称C1和C2为C12的 **亲本子句**。

---

【例子】
1. 设C1=¬Q，C2=Q，则C1和C2的消解式C12 = NIL .
2. 设C1=P∨Q∨R，C2=¬P∨S，则C1和C2的消解式C12 = Q∨R∨S .
3. 设C1 =¬P ∨ Q ，C2=¬Q，C3=P，则C1、C2、C3的消解式C123 = NIL .

---

* 很显然，可以得出定理：**消解式C12是其亲本子句C1和C2的逻辑结论。**根据该定理，可以得到以下推论：
    - 推论1：设C1和C2是子句集S中的两个子句，C12是C1和C2的消解式，若用C12代替C1和C2后得到新的子句集S1，则由S1的不可满足性可以推出原子句集S的不可满足性。即：
    `S1的不可满足性⇔S的不可满足性`
    - 推论2：设C1和C2是子句集S中的两个子句，C12是C1和C2的消解式，若把C12加入S中得到新的子句集S2，则S与S2的不可满足性是等价的。即：
    `S2的不可满足性⇔S的不可满足性`

上述两个推论说明，*为证明子句集S的不可满足性，只要对其中可进行消解得子句进行消解，**并把消解式加入到子句集S中，或者用消解式代替他的亲本子句**，然后对新的子句集证明其不可满足性就可以了*。
如果经消解能得到空子句，根据空子句的不可满足性，即可得到原子句集S是不可满足的结论。
在命题逻辑中，对不可满足的子句集S，其消解原理是完备的。即：**子句集S是不可满足的，当且仅当存在一个从S到空子句的消解过程。**

应用消解原理证明定理的过程称为 **消解反演**。

> 命题逻辑的消解反演：

在命题逻辑中，已知F，证明G为真的消解反演过程如下：
1. 否定目标公式G，得¬G;
2. 把¬G并入到公式集F中，得到{F，¬G}；
3. 把{F，¬G}化为子句集S；
4. 应用消解原理对子句集S中的子句进行消解，并把每次得到的消解式并入S中。如此反复进行，若 **出现空子句**，则停止消解，此时就证明了G为真。

---

【例子】 设已知的公式集为`{P,(P∧Q)→R,(S∨T)→Q,T}`，求证：R为真。

解：假设结论R为假, 将¬R加入公式集，并化为子句集：
    `S={P,¬P∨¬Q∨R,¬S∨Q,¬T∨Q,T,¬R}`
其消解过程如下图的消解演绎树所示。
![](https://i.loli.net/2019/02/24/5c71700dc0e44.jpg)

该树根为空子句NIL，则子句集S不可满足，即假设有误，于是证得R为真。

---

>谓词逻辑的消解

* 在谓词逻辑中，由于子句集中的谓词一般都含有变元，因此不能象命题逻辑那样直接消去互补文字。
* 对于谓词逻辑，需要先用一个最一般合一对变元进行置换，然后才能进行消解。

设C1和C2是两个没有公共变元的子句，L1和L2分别是C1和C2中的文字。如果 σ 是L1和¬ L2存在的`最一般合一`，则称：
    `C12=({C1σ}-{ L1σ})∪({ C2σ}-{ L2σ})`
为C1和C2的二元消解式，L1和L2为消解式上的文字。

**注意**：在谓词逻辑的消解过程中，要注意以下几个问题：
1. 若C1和C2有相同的变元x，需要将其中一个变元更名。（例2）
2. 求消解式不能同时消去两个互补对，消去这两个互补文字所得的结果不是两个亲本子句的逻辑结论。(例3)
3. 对参加消解的某个子句，若其内部有可合一的文字，则在进行消解之前应先对这些文字进行合一，以实现这些子句内部的化简。(例4)

---

【例子】
例1、设`C1=P(a)∨R(x)`，`C2=¬P(y)∨Q(b)`，求 C12。
解：取`L1= P(a)`, `L2=¬P(y)`，则L1和¬L2的最一般合一是`σ={a/y}`。因此：

```
    C12 = ( {C1σ}-{L1σ}) ∪ ({C2σ}-{L2σ})
        = ({P(a), R(x)}-{P(a)})∪({¬P(a), Q(b)}-{¬P(a)})
        = ({R(x)})∪({Q(b)})
        = { R(x), Q(b) }
        = R(x)∨Q(b)
```

例2、设`C1=P(x)∨Q(a)`，`C2=¬P(b)∨R(x) `，求 C12。
解：由于C1和C2有相同的变元x，不符合定义的要求。为了进行消解，需要修改C2中变元的名字。令`C2=¬P(b)∨R(y)`，此时`L1= P(x)`, `L2 =¬P(b)`，L1和¬L2的最一般合一是 `σ={b/x}`。则有:

```
    C12 = ({C1σ}-{L1σ})∪ ({C2σ}-{L2σ})
        = ({P(b), Q(a)}-{P(b)}) ∪ ({¬P(b), R(y)}-{¬P(b)})
        = ({Q(a)}) ∪ ({R(y)})
        = {Q(a), R(y)}
        = Q(a)∨R(y)
```

例3、设 `C1=P(a)∨¬Q(x)`，`C2=¬P(y)∨Q(b)`，求C12。
解：对C1和C2通过最一般合一（`σ={b/x, a/y}`）的作用，便得到空子句NIL的结论，从而得出C1、C2互相矛盾的结论，而事实上C1、C2并无矛盾。

例4、设 `C1=P(x)∨P(f(a))∨Q(x)` ，`C2=¬P(y)∨R(b)`，求C12。
解：本例的C1中有可合一的文字P(x)与P(f(a))，用它们的最一般合一`σ={f(a)/x}`进行代换，可得到 ：
`C1σ=P(f(a))∨Q(f(a))`
此时对C1σ与C2进行消解。选`L1= P(f(a))`, `L2 =¬P(y)`，L1和L2的最一般合一是`σ={f(a)/y}`，则可得到C1和C2的二元消解式为：
`C12=R(b)∨Q(f(a))`

例5、设 `C1=P(y)∨P(f(x))∨Q(g(x))`、`C2=¬P(f(g(a)))∨Q(b)`，求C12。
解：对C1，取最一般合一` σ={f(x)/y}`，得C1的因子`C1σ=P(f(x))∨Q(g(x))`，对C1的因子和C2消解（`σ={g(a)/x }`），可得：`C12=Q(g(g(a)))∨Q(b)`

---

>谓词逻辑的消解反演：

在谓词逻辑中，已知F，证明G是F的结论的消解反演过程如下：
1. 否定目标公式G，得¬G;
2. 把¬G并入到公式集F中，得到{F，¬G}；
3. 把{F，¬G}化为子句集S；
4. 应用消解原理对子句集S中的子句进行消解，并把每次得到的消解式并入S中。如此反复进行，若出现空子句，则停止消解，此时就证明了G为真。

与命题逻辑的消解反演过程比较一下
* 步骤基本相同，但每步的处理对象不同。
* 在步骤(3)化简子句集时，谓词逻辑需要把由谓词构成的公式集化为子句集。
* 在步骤(4)按消解原理进行消解时，谓词逻辑的消解原理需要考虑两个亲本子句的最一般合一。

---

【例子】
例1、已知`F:(∀x)((∃y)(A(x, y)∧B(y))→(∃y)(C(y)∧D(x, y)))`、`G:¬(∃x)C(x)→(∀x)(∀y)(A(x, y)→¬B(y))`，求证G是F的逻辑结论。

证明：
第一步，先把G否定，并放入F中，得到的`{F,¬G}`：
    `{(∀ x)((∃ y)(A(x,y)∧B(y))→(∃ y)(C(y)∧D(x,y)))`，`¬(¬(∃ x)C(x)→(∀ x)(∀ y)(A(x,y)→¬ B(y)))}`
第二步，把{F,¬G}化成子句集，得到
    (1) `¬A(x,y)∨¬B(y)∨C(f(x))`
    (2) `¬A(u,v)∨¬B(v)∨D(u,f(u))`
    (3) `¬C(z)`
    (4) `A(m,n)`
    (5) `B(k)`
第三步，应用谓词逻辑的消解原理对上述子句集进行消解，其过程为：
    (6) `¬ A(x,y)∨¬ B(y)`    *(1)和(3)消解，取σ={f(x)/z}*
    (7) `¬ B(n) `             *(4)和(6)消解，取σ={m/x,n/y}*
    (8) `NIL`                  *(5)和(7)消解，取σ={n/k}*
最后，“G是F的逻辑结论”得证。

上述消解过程可用如下消解树来表示
![](https://i.loli.net/2019/02/24/5c71700ee5dbe.jpg)

例2、**“快乐学生”问题**
假设：任何通过计算机考试并获奖的人都是快乐的，任何肯学习或幸运的人都可以通过所有考试，张不肯学习但他是幸运的，任何幸运的人都能获奖。
求证：张是快乐的。

证明：(完整的解题过程)
第一步，先定义谓词：
    Pass(x, y)：x可以通过y考试
    Win(x, prize)：x能获得奖励
    Study(x) ：x肯学习
    Happy(x)：x是快乐的
    Lucky(x) ：x是幸运的
第二步，将已知条件以及结论的否定用谓词表示如下：
    “任何通过计算机考试并奖的人都是快乐的”
            `(∀x)(Pass(x, computer)∧Win(x, prize)→Happy(x))`
    “任何肯学习或幸运的人都可以通过所有考试”
            `(∀x)(∀y)(Study(x)∨Lucky(x)→Pass(x, y))`
    “张不肯学习但他是幸运的”
            `¬Study(zhang)∧Lucky(zhang)`
    “任何幸运的人都能获奖”
            `(∀x)(Lucky(x)→Win(x, prize))`
    结论“张是快乐的”的否定
            `¬Happy(zhang)`
第三步，将上述谓词公式转化为子句集如下：
    1. `¬Pass(x, computer)∨¬Win(x, prize)∨Happy(x)`
    2. `¬Study(y)∨Pass(y, z)`
    3. `¬Lucky(u)∨Pass(u, v)`
    4. `¬Study(zhang)`
    5. `Lucky(zhang)`
    6. `¬Lucky(w)∨Win(w, prize)`
    7. `¬ Happy(zhang)`    (结论的否定)
第四步，按消解原理进行消解，消解树如下：
    ![](https://i.loli.net/2019/02/24/5c71700f755dd.jpg)

最后，“张是快乐的”得证。

---

##### 消解反演推理的消解策略

>在消解演绎推理中，由于事先并不知道哪些子句对可进行消解，更不知道通过对哪些子句对的消解能尽快得到空子句，因此就需要对子句集中的所有子句逐对进行比较，直到得出空子句为止。这种盲目的全面进行消解的方法，不仅会产生许多无用的消解式，更严重的是会产生组核爆炸问题。因此，需要研究有效的消解策略来解决这些问题。

常用的消解策略可分为两大类：
* 限制策略：通过限制参加消解的子句减少盲目性
* 删除策略：通过删除某些无用的子句缩小消解范围

##### 用消解反演求取问题的答案

消解原理除了可用于 **定理证明**外，还可用来 **求取问题答案**，其思想与定理证明相似。
其一般步骤为：
1. 把问题的已知条件用谓词公式表示出来，并化为子句集；
2. 把问题的目标的否定用谓词公式表示出来，并化为子句集；
3. 对目标否定子句集中的每个子句，构造该子句的重言式（即把该目标否定子句和此目标否定子句的否定之间再进行析取所得到的子句），用这些重言式代替相应的目标否定子句式，并把这些重言式加入到前提子句集中，得到一个新的子句集；
4. 对这个新的子句集，应用消解原理求出其证明树，这时证明树的根子句不为空，称这个证明树为修改的证明树；
5. 用修改证明树的根子句作为回答语句，则答案就在此根子句中。

---

【例子】
例1、已知：“张和李是同班同学，如果x和y是同班同学，则x的教室也是y的教室，现在张在302教室上课。”
问：“现在李在哪个教室上课？”

解：第一步，首先定义谓词
    `C(x, y)`：x和y是同班同学
    `At(x, u)`：x在u教室上课。
第二步，把已知前提用谓词公式表示如下：
    `C(zhang, li)`
    `(∀x)(∀y)(∀u)(C(x, y)∧At(x, u)→At(y,u))`
    `At(zhang, 302)`
把目标的否定用谓词公式表示如下：
    `¬(∃v)At(li, v) `
第三步，把上述表示前提的谓词公式化为子句集：
    `C(zhang, li)`
    `¬C(x, y)∨¬At(x, u)∨At(y, u)`
    `At(zhang, 302)`
把目标的否定化成子句式，并用下面的 **重言式**代替：
         `¬At(li,v) ∨At(li,v)`
第四步，把此 **重言式**加入前提子句集中，得到一个新的子句集，对这个新的子句集，应用消解原理求出其证明树。
求解过程如下图所示。该证明树的根子句就是所求的答案，即“李明在302教室”。
![](https://i.loli.net/2019/02/24/5c71700f30b16.jpg)

例2、已知：A,B,C三人中有人从不说真话，也有人从不说假话。某人向这三人分别提出同一个问题：谁是说谎者？
    A答：“B和C都是说谎者”；
    B答：“A和C都是说谎者”；
    C答：“A和B中至少有一个是说谎者”。
问：求谁是老实人，谁是说谎者？

解：第一步，首先定义谓词
`T(x)`：表示x说真话
第二步，把已知前提用谓词公式表示如下：
    有人从不说真话：`¬T(C)∨¬T(A)∨¬T(B)`
    有人从不说假话：`T(C)∨T(A)∨T(B)`
根据“A答：B和C都是说谎者”，则
    若A说真话：`T(A)→¬T(B)∧¬T(C)`
    若A说假话： `¬T(A)→T(B)∨T(C)`
同理，根据“B答：A和C都是说谎者”，则
    `T(B)→¬T(A)∧¬T(C)`
    `¬T(B)→T(A)∨T(C)`
根据“C答：A和B中至少有一个是说谎者”，则
    `T(C)→¬T(A)∨¬T(B)`
    `¬T(C)→T(A)∧T(B)`
第三步，把上述公式化成子句集，得到前提子句集S：
    `¬T(A)∨¬T(B)`
    `¬T(A)∨¬T(C)`
    `T(C)∨T(A)∨T(B)`
    `¬T(B)∨¬T(C)`
    `¬T(C)∨¬T(A)∨¬T(B)`
    `T(A)∨T(C)`
    `T(B)∨T(C)`
第四步，先求谁是老实人，结论的否定为：`¬(∃x)T(x)`，把目标的否定化成子句式，并用下面的重言式代替：
    `¬T(x)∨T(x)`
把此重言式加入前提子句集S，得到一个新子句集。
第五步，对这个新的子句集，应用消解原理求出其证明树。
    ![](https://i.loli.net/2019/02/24/5c71700ee9580.jpg)

第六步，同理证明A不是老实人，结论的否定为： ¬T(A)，将结论的否定¬(¬T(A)) 加入并入前提子句集S中，应用消解原理对新的子句集进行消解：
    ![](https://i.loli.net/2019/02/24/5c71700ee7a7f.jpg)

---

##### 消解演绎推理的优缺点：
* 优点：
    - 简单，便于在计算机上实现。
* 缺点：
    - 必须把逻辑公式化成子句集。
    - 不便于阅读与理解：¬P(x)∨Q(x)没有P(x)→Q(x)直观。
    - 可能丢失控制信息，如下列逻辑公式，化成子句后都是: A∨B∨C
```
    (¬A∧¬B)→C    ¬A→(B∨C)
    (¬A∧¬C)→B    ¬B→(A∨C)
    (¬C∧¬B)→A    ¬C→(B∨A)
```

#### 基于规则的演绎推理

>在消解演绎推理中，需要把谓词公式化为子句形，这使得原来蕴含在谓词公式中的一些重要信息却会在求取子句形的过程中被丢失。
>在不少情况下人们多希望使用接近于问题原始描述的形式来进行求解，而不希望把问题描述化为子句集。

基于规则的演绎推理又称为与/或形演绎推理，不再把有关知识转化为子句集，而是把领域知识及已知事实分别用蕴含式及与/或形表示出来，然后通过运用蕴含式进行演绎推理，从而证明某个目标公式。

规则是一种比较接近于人们习惯的问题描述方式，按照 **蕴含式**（“If →Then”规则）这种问题描述方式进行求解的系统称为基于规则的系统，或者叫做 **规则演绎系统**。

规则演绎系统按照推理方式可分为：
* 规则正向演绎系统
* 规则逆向演绎系统(ppt-14)
* 规则双向演绎系统(ppt-14)

##### 规则正向演绎系统

首先说明一下，在规则正向演绎系统中，对已知事实和规则都有一定的要求，如果不是所要求的形式，需要进行变换。

事实表达式的与或形变换
* 在基于规则的正向演绎系统中，把事实表示为非蕴含形式的与或形，作为系统的总数据库；
* 把一个公式化为与或形的步骤与化为子句集类似，只是不必把公式化为子句的合取形式，也不能消去公式中的合取。

详细来说，把事实表达式化为非蕴含形式的与/或形的步骤如下：
1. 利用 “P→Q⇔﹁P∨Q”，消去蕴含符号；
2. 利用狄.摩根定律及量词转换率把“﹁”移到紧靠谓词的位置，直到否定符号的辖域最多只含一个谓词为止；
3. 重新命名变元，使不同量词约束的变元有不同的名字；
4. 对存在量词量化的变量用skolem函数代替；
5. 消去全称量词，且使各主要合取式中的变元具有不同的变量名。

---

【例子】
有如下表达式
        `(∃x) (∀y)(Q(y, x)∧﹁((R(y)∨P(y))∧S(x, y)))`
可把它转化为：
        `Q(z, a)∧(  ( ﹁R(y)∧﹁P(y) )∨﹁S(a, y)  )`
这就是 **与/或形表示**，也可用一棵与/或图表示出来。
![](https://i.loli.net/2019/02/24/5c7171a4622da.jpg)


---

>关于 **与/或图**说明以下几点：

* 当某表达式为k个子表达式的析取：`E1∨E2∨…∨Ek`，其中每个子表达式Ei均被表示为`E1∨E2∨…∨Ek`的后继节点，并由一个k线连接符（即图中的半圆弧）将这些后继节点都连接到其父节点，即表示成与的关系。
* 当某表达式为k个子表达式的合取：`E1∧E2∧…∧Ek`，其中的每个子表达式Ei均被表示为`E1∧E2∧…∧Ek`的一个单一的后继节点，无需用连接符连接，即表示成或的关系。
* **这样，与/或图的根节点就是整个事实表达式，叶节点均为事实表达式中的一个文字**。

>有了与/或图的表示，就可以求出其解树（结束于文字节点上的子树）集。可以发现，事实表达式的子句集与解树集之间存在着一一对应关系，即 **解树集中的每个解树都对应着子句集中的一个子句**。
>**解树集中每个解树的端节点上的文字的析取就是子句集中的一个子句。**

上面那个与/或图有3个解树，分别对应这以下3个子句：
    `Q(z, a)`、`﹁R(y)∨ ﹁ S(a, y)`、`﹁P(y)∨ ﹁ S(a, y)`

>还需要注意以下两点：
* 这里的与/或图是作为综合数据库的一种表示，其中的变量受全称量词的约束。
* 在之前 问题归约表示 中所描述的 **与/或图表示方法**与这里 **与/或形的与/或图表示**有着不同的目的和含义，因此应用时应加以 **区分**。


> 规则的表示

为简化演绎过程，通常要求规则具有如下形式：`L→W`，其中，L为单文字，W为与/或形公式。
(之所以限制前件L为单文字，是因为在进行正向演绎推理时要用规则作用于表示事实的与/或树，而该与/或树的叶节点都是单文字，这样就可用规则的前件与叶节点进行简单匹配。对非单文字情况，若形式为L1∨L2→W，则可将其转换成与之等价的两个规则L1→W与 L2→W进行处理。)

* 假定出现在蕴含式中的任何变量全都受全称量词的约束，并且这些变量已经被换名，使得他们与事实公式和其他规则中的变量不同。
* 如果领域知识的规则表示形式与上述要求不同，则应将它转换成要求的形式。

>将规则转换为要求形式的步骤：

1、 暂时消去蕴含符号“→”。设有如下公式：
        `(∀x)(((∃y) (∀ z)P(x, y,z))→(∀u)Q(x, u))`
运用等价关系“P→Q⇔﹁P∨Q”，可将上式变为：
        `(∀x)(﹁((∃ y) (∀z)P(x, y,z))∨(∀u)Q(x, u))`
2、 把否定符号“﹁”移到紧靠谓词的位置上，使其作用域仅限于单个谓词。通过使用狄.摩根定律及量词转换律可把上式转换为：
        `(∀ x)( (∀y) (∃z)﹁P(x, y,z))∨ (∀u)Q(x, u))`
3、 引入Skolem函数，消去存在量词。消去存在量词后，上式可变为：
        `(∀ x)( (∀y) (﹁P(x, y,f(x,y)))∨(∀u)Q(x, u))`
4、 把所有全称量词移至前面化成前束式，消去全部全称量词。消去全称量词后，上式变为：
        `﹁P(x, y,f(x,y))∨Q(x, u)`
此公式中的变元都被视为受全称量词约束的变元。
5、 恢复蕴含式表示。利用等价关系“`﹁P∨Q⇔P→Q`”将上式变为：
        `P(x, y,f(x,y))→Q(x, u)`

>目标公式的表示形式

* 与/或树正向演绎系统要求目标公式用子句形表示。如果目标公式不是子句形，则需要化成子句形。

>推理过程

规则正向演绎推理过程是从已知事实出发，不断运用规则，推出欲证明目标公式的过程。
先用与/或树把已知事实表示出来，然后再用规则的前件和与/或树的叶节点进行匹配，并通过一个匹配弧把匹配成功的规则加入到与/或树中，依此使用规则，直到产生一个含有以目标节点为终止节点的解树为止。

>下面分命题逻辑和谓词逻辑两种情况来讨论规则正向演绎过程。

**命题逻辑的规则正向演绎过程**
已知事实：`A∨B`
规则：`r1: A→C∧D`，`r2:  B→E∧G`
目标公式：`C∨G`

证明：
1）先将已知事实用与/或树表示出来；
2）然后再用匹配弧把r1和r2分别连接到事实与/或树中与r1和r2 的前件匹配的两个不同端节点；
3) 由于出现了以目标节点为终节点的解树，故推理过程结束。这一证明过程可用下图表示。
![](https://i.loli.net/2019/02/24/5c7171a47248c.jpg)

**谓词逻辑的规则正向演绎过程**
已知事实的与/或形表示：P(x, y)∨(Q(x)∧R(v, y))
规则：P(u, v)→(S(u)∨N(v))
目标公式：S(a)∨N(b)∨Q(c)

证明：
在谓词逻辑情况下，由于事实、规则及目标中均含有变元，因此，其规则演绎过程还需要用最一般合一对变进行置换。证明过程可用下图表示。
![](https://i.loli.net/2019/02/24/5c7171a481b87.jpg)

#### 产生式系统

##### 基本结构

产生式系统的 **基本结构**由 **数据库**、**产生式规则**和 **控制策略**三部分构成。

* 总数据库：存放求解问题的各种当前信息，如：问题的初始状态，输入的事实，中间结论及最终结论等。
    - 推理过程中，当规则库中某条规则的前提可以和总数据库的已知事实匹配时，该规则被激活，由它推出的结论将被作为新的事实放入总数据库，成为后面推理的已知事实。
* 产生式规则：是一个规则库，也称知识库 。用于存放与求解问题有关的所有规则的集合。
* 控制策略：亦称推理机，用于控制整个产生式系统的运行，决定问题求解过程的推理线路。
    - 控制系统的主要任务包括： 选择匹配、 冲突消解、 执行操作、 终止推理、 路径解释...

##### 产生式系统的推理

产生式系统的推理分为 **正向推理**、**逆向推理**和 **双向推理**三种形式。

##### 主要优缺点

产生式系统的主要 **优缺点**
* 优点：
    - 自然性：采用“如果……，则……”的形式，人类的判断性知识基本一致。
    - 模块性：规则是规则库中最基本的知识单元，各规则之间只能通过总数据库发生联系，而不能相互调用，从而增加了规则的模块性。
    - 有效性：产生式知识表示法既可以表示确定性知识，又可以表示不确定性知识，既有利于表示启发性知识，又有利于表示过程性知识。
* 缺点：
    - 效率较低：各规则之间的联系必须以总数据库为媒介。并且，其求解过程是一种反复进行的“匹配—冲突消解—执行”过程。这样的执行方式将导致执行的低效率。
    - 不便于表示结构性知识：由于产生式表示中的知识具有一致格式，且规则之间不能相互调用，因此那种具有结构关系或层次关系的知识则很难以自然的方式来表示。


## 非经典推理

### 经典推理和非经典推理
#### 非经典推理
现实世界中的大多数问题存在随机性、模糊性、不完全性和不精确性。对于这些问题，若采用前面所讨论的精确性推理方法显然是无法解决的。
为此，出现了一些新的逻辑学派，称为非经典逻辑，相应的推理方法称为 **非经典推理**。包括非单调性推理、不确定性推理、概率推理和贝叶斯推理等。

#### 非经典逻辑推理与经典逻辑推理的区别
* 在推理方法上，经典逻辑采用演绎逻辑推理，非经典逻辑采用归纳推理。
* 在辖域取值上，经典逻辑是二值逻辑，非经典逻辑是多值逻辑。
* 在运算法则上，两者大不相同。
* 在逻辑运算符上，非经典逻辑有更多的逻辑运算符。
* 在单调性上，经典逻辑是单调的，即已知事实均为充分可信的，不会随着新事实的出现而使原有事实变为假。非经典逻辑是非单调的。


### 不确定性推理
#### 不确定性推理的概念
* 不确定性推理是建立在非经典逻辑基础上的一种推理，它是对不确定性知识的运用与处理。
* 不确定性推理泛指除精确推理以外的其它各种推理问题。包括不完备、不精确知识的推理，模糊知识的推理，非单调性推理等。
* 不确定性推理从不确定性的初始证据（即事实）出发，通过运用不确定性的知识，最终推出具有一定程度不确定性的结论。

#### 为什么要采用不确定性推理
* 所需知识不完备或问题的背景知识不足
* 所需知识描述不精确或模糊
* 多种原因导致同一结论或解题方案不唯一

#### 不确定性推理的基本问题
1. 不确定性的表示
2. 不确定性的匹配
3. 组合证据的不确定性的计算
4. 不确定性的更新
5. 不确定性结论的合成

#### 知识的不确定性的表示
* 考虑因素：1. 问题描述能力; 2. 推理中不确定性的计算
* 含义：知识的确定性程度，或静态强度
* 表示：
    - 概率，[0,1]，0接近于假，1接近于真
    - 可信度，[-1,1]，大于0接近于真，小于0接近于假

#### 证据的非精确性表示
* 证据来源：初始证据，中间结论
* 表示：用概率或可信度

#### 不确定性的匹配
* 含义：不确定的前提条件与不确定的事实匹配
* 问题：前提是不确定的，事实也是不确定的
* 方法：设计一个计算相似程度的算法，给出相似的限度
* 标志：相似度落在规定限度内为匹配，否则为不匹配

#### 组合证据不确定性的计算
* 含义：知识的前提条件是多个证据的组合
* 方法：**T(E)表示证据E为真的程度**
    - 最大最小法：
    `T(E1 AND E2)=min{T(E1),T(E2)}`
    `T(E1 OR E2)=max{T(E1),T(E2)}`
    - 概率法：在事件之间完全独立时使用
    `T(E1 AND E2)=T(E1)T(E2)`
    `T(E1 OR E2)=T(E1)＋T(E2)－T(E1)T(E2)`
    - 有界法：
    `T(E1 AND E2)=max{0,T(E1)＋T(E2)－1}`
    `T(E1 OR E2)=min{1,T(E1)＋T(E2)}`

#### 不确定性的更新
* 主要问题：解决不确定性知识在推理的过程中，知识不确定性的累积和传递。
* 解决方法
    - 已知规则前提证据E的不确定性`T(E)`和规则的强度`F(E,H)`，则结论H的不确定性：`T(H) = g1[T(E),F(E,H)] `
    - 证据合取： `T(E1 AND E2) = g2[T(E1), T (E2)] `
    - 证据析取： `T(E1   OR  E2) = g3[T(E1), T (E2)] `

#### 不确定性结论的合成
* 主要问题：多个不同知识推出同一结论，且不确定性程度不同
* 解决方法：
    - 并行规则算法：根据独立证据E1和E2分别求得结论H的不确定性为`T1(H)`和`T2(H)`，则证据E1和E2的组合导致结论H的不确定性：`T(H)=g[T1(H), T2(H)]`
    - 函数g视不同推理方法而定

### 概率推理
#### 概率论基础回顾

* [全概率公式](https://baike.baidu.com/item/%E5%85%A8%E6%A6%82%E7%8E%87%E5%85%AC%E5%BC%8F)
* [贝叶斯(Bayes)公式](https://baike.baidu.com/item/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%85%AC%E5%BC%8F/9683982)

#### 概率推理方法
* 设有如下产生式规则：IF  E   THEN   H
    - 其中，E为前提条件，H为结论。
    - 条件概率P(H|E)可以作为在证据E出现时结论H的确定性程度，即规则的静态强度。
* 把贝叶斯方法用于不精确推理的思想
    - 已知前提E的概率P(E)和结论H的先验概率P(H)
    - 已知H成立时E出现的条件概率P(E|H)
    - 利用规则推出H在E出现的条件下的后验概率：

    ![](https://i.loli.net/2019/02/24/5c7171a3de085.jpg)

* 对于一组产生式规则：IF  E   THEN  Hi
    - 一个前提条件E支持多个结论H1, H2, ...,Hn
    - 同样有后验概率如下（ Hi 确定性的程度，或规则的静态强度）：

    ![](https://i.loli.net/2019/02/24/5c7171a41b712.jpg)

* 对于有多个证据E1, E2, …, Em和多个结论H1, H2, ..., Hn,并且每个证据都以一定程度支持结论的情况，上面的式子可进一步扩展为:

    ![](https://i.loli.net/2019/02/24/5c7171a45cf31.jpg)

---

【例子】
设H1,H2,H3分别是三个结论，E是支持这些结论的证据。已知：
```
P(H1)=0.3
P(H2)=0.4
P(H3)=0.5
P(E|H1)=0.5
P(E|H2)=0.3
P(E|H3)=0.4
```
求P(H1|E),P(H2|E)及P(H3|E)的值各是多少？

解：

![](https://i.loli.net/2019/02/24/5c7171a455766.jpg)

同理可得：
P(H2|E)=0.26
P(H3|E)=0.43
观察：( 注：P(E)=0.47 )
P(H1)=0.3 , P(E|H1)=0.5     P(H1|E)=0.32
P(H2)=0.4 , P(E|H2)=0.3     P(H2|E)=0.26
P(H3)=0.5 , P(E|H3)=0.4     P(H3|E)=0.43
结论：由于E的出现，H1成立的可能性增加，H2和H3成立的可能性不同程度的下降。

---

#### 概率推理方法的特点
* 优点：
    - 概率推理方法有较强的理论背景和良好的数学特性，当证据彼此独立时计算的复杂度比较低。
* 缺点：
    - 概率推理方法要求给出结论Hi的先验概率P(Hi)及条件概率 P(Ej|Hi)。

### 贝叶斯推理（主观贝叶斯方法）

>使用概率推理方法求结论Hi在存在证据E时的条件概率P(Hi|E) ，需要给出结论Hi的先验概率P(Hi)及证据E的条件概率 P(E|Hi)。这对于实际应用是不容易做到的。
>Duda 和 Hart 等人在贝叶斯公式的基础上，于1976年提出主观贝叶斯方法，建立了不精确推理的模型，并把它成功地应用于PROSPECTOR专家系统（PROSPECTOR是国际上著名的一个用于勘察固体矿的专家系统）。

#### 主观贝叶斯方法(ppt-24)
* 知识不确定性的表示

    - 在主观Bayes方法中，知识是用产生式表示的，其形式为：
    `IF  E  THEN  (LS, LN)   H`
    - E表示规则前提条件，它既可以是一个简单条件，也可以是用AND或OR把多个简单条件连接起来的复合条件。
    - H是结论，用P(H)表示H的先验概率，它指出没有任何专门证据的情况下结论H为真的概率，其值由领域专家根据以往的实践经验给出。

    - LS是规则的充分性度量。用于指出E对H的支持程度，取值范围为[0,+∞)，其定义为：

    ![](https://i.loli.net/2019/02/24/5c7173002e915.jpg)

    - LN是规则的必要性度量。用于指出E对H为真的必要程度，即﹁E对对H的支持程度。取值范围为[0,+∞)，其定义为：

    ![](https://i.loli.net/2019/02/24/5c71730072035.jpg)

* 证据不确定性的表示
* 组合证据不确定性的计算
* 不确定性的更新
* 主观贝叶斯方法的推理过程

### 可信度方法

> 什么是可信度

* 可信度是指人们根据以往经验对某个事物或现象为真的程度的一个判断，或者说是人们对某个事物或现象为真的相信程度。
* 在可信度方法中，由专家给出规则或知识的可信度，从而 **避免对先验概率、条件概率的要求**。
* 可信度方法是肖特里菲（Shortliffe）等人在确定性理论基础上结合概率论等理论提出的一种不精确推理模型。

该方法 **直观**、**简单**而且 **效果好**，在专家系统等领域获得了较为广泛的应用。

>C-F模型

C-F模型：基于可信度表示的不确定性推理的基本方法，其他可信度方法都是基于此发展而来。

>知识的不确定性表示

知识的不确定性表示：在C-F模型中，知识是用产生式规则表示的，其一般形式为：
                 `IF   E   THEN   H (CF(H, E))`
`E`：知识的前提条件，可以是单一或复合条件；
`H`：知识的结论，可以是单一结论或多个结论；
`CF(H, E)`：知识的可信度，称为 **可信度因子**(Certainty Factor)或规则强度。

一般情况下，CF(H, E)的取值为[-1, 1]，表示当证据E为真时，对结论H的支持程度。其值越大，表示支持程度越大。
* CF(H,E)>0对应于P(H|E)>P(H)；
* CF(H,E)=0对应于P(H|E)=P(H)；
* CF(H,E)<0对应于P(H|E)<P(H)。

例如：`IF   发烧  AND  流鼻涕   THEN   感冒(0.7)`，表示当某人确实有“发烧”及“流鼻涕”症状时，则有七成的把握是患了感冒。

>CF(H,E)的定义:

`CF(H,E) = MB(H,E) - MD(H,E)`

* MB ( Measure Belief ) 称为信任增长度，反映了证据对结论有利的一面。MB(H, E)定义为：
*
![](https://i.loli.net/2019/02/24/5c7173006871b.jpg)

* MD ( Measure Disbelief ) 称为不信任增长度，MD反映了证据对结论不利的一面。MD(H,E)定义为：
*
![](https://i.loli.net/2019/02/24/5c71730066f42.jpg)

>MB和MD的关系：

* 当`P(H|E)>P(H)`时： E的出现增加了H的概率
`MB(H,E)>0，MD(H,E)=0`
* 当`P(H|E)<P(H)`时： E的出现降低了H的概率
`MB(H,E) =0，MD(H,E)>0`
因此，CF(H, E)的计算公式：

![](https://i.loli.net/2019/02/24/5c717300bd402.jpg)

>可信度的性质(ppt-25)

* 互斥性：对同一证据，不可能既增加对H的信任程度，又同时增加对H的不信任程度，即MB与MD是互斥的
    - 当MB(H, E)>0时，MD(H, E)=0
    - 当MD(H, E)>0时，MB(H, E)=0
* 值域：MB(H, E) ∈ [0,1]; MD(H, E) ∈ [0,1]; CF(H, E) ∈[-1,1],
    - 当且仅当P(H|E)=1时,  CF(H,E)=1
    - 当且仅当P(H|E)=0时,  CF(H,E)=-1
    - CF(H,E)定性地反映了P(H|E)的大小，因此可以用CF(H,E)近似表示P(H|E) ，描述规则的可信度。
* 对H的信任增长度等于对非H的不信任增长度
![](https://i.loli.net/2019/02/24/5c717300d1b44.jpg)
* 再根据CF的定义和MB、MD的互斥性有
` CF(H,E)+CF(﹁H,E)=0`
* 对前提E，若支持若干个不同的结论Hi(i=1,2,…,n)，则
* 因此，如果发现专家给出的知识有如下情况
`CF(H1, E)=0.7,  CF(H2, E)=0.4`
* 则因0.7+0.4=1.1>1为非法，应进行调整或规范化。

>证据不确定性的表示

* 证据的E不确定性也用可信度因子CF(E)表示
* CF(E)的取值范围：[-1，+1]。
    - CF(E)=1，证据E肯定它为真
    - CF(E)=-1，证据E肯定它为假
    - CF(E)=0，对证据E一无所知
    - 0<CF(E)<1，证据E以CF(E)程度为真
    - -1<CF(E)<0，证据E以CF(E)程度为假

>否定证据的不确定性计算

`CF(¬E)=－CF(E)`

>组合证据的不确定性计算

* 可采用最大最小法
    - 当组合证据E是多个单一证据的合取时，若已知`CF(E1), …, CF(En)`，则:
    `CF(E)=min{CF(E1), CF(E2), … ,CF(En)}`
    - 当组合证据E是多个单一证据的析取时，若已知`CF(E1), …, CF(En)`，则:
    `CF(E)=max{CF(E1), CF(E2), … ,CF(En)}`

>不确定性的更新

`IF   E   THEN   H  (CF(H, E))　`

>结论H的可信度由下式计算：

`CF(H)=CF(H,E)×max{0,CF(E)}`

* CF(H)的取值范围：[-1，+1]。
    - CF(H)=0: CF(E)<0,即该模型没考虑E为假对H的影响
    - CF(H)>0: 表示结论以某种程度为真
    - CF(H)<0: 表示结论以某种程度为假

>结论不确定性的合成

* 若由多条不同知识推出了相同的结论，但可信度不同，则用合成算法求出综合可信度。设有知识：
`IF  E1   THEN   H  (CF(H, E1))`
`IF  E2   THEN   H  (CF(H, E2))`
* 则结论H 的综合可信度可分以下两步计算：
(1)、分别对每条知识求出其CF(H)。即
 `CF1(H)=CF(H, E1) ×max{0, CF(E1)}`
 `CF2(H)=CF(H, E2) ×max{0, CF(E2)}`

(2)、用如下公式求E1与E2对H的综合可信度

![](https://i.loli.net/2019/02/24/5c717300df62b.jpg)

---

【例子】
设有如下一组知识：
```
r1：IF  E1  THEN  H  (0.9)
r2：IF  E2  THEN  H  (0.6)
r3：IF  E3  THEN  H  (-0.5)
r4：IF  E4  AND  ( E5  OR  E6)  THEN  E1  (0.8)
```

![](https://i.loli.net/2019/02/24/5c71730075bb3.jpg)

已知：`CF(E2)=0.8`，`CF(E3)=0.6`，`CF(E4)=0.5`，`CF(E5)=0.6`,`CF(E6)=0.8`，求：`CF(H)`。

解：由r4得到：
```
 CF(E1) = 0.8×max{0, CF(E4  AND  (E5  OR   E6))}
        = 0.8×max{0, min{CF(E4),  CF(E5  OR   E6)}}
        = 0.8×max{0, min{CF(E4),  max{CF(E5),  CF(E6)}}}
        = 0.8×max{0, min{CF(E4),  max{0.6,  0.8}}}
        = 0.8×max{0, min{0.5,  0.8}}
        = 0.8×max{0,  0.5}
        = 0.4
 由r1得到：
    CF1(H) = CF(H, E1)×max{0,  CF(E1)}
           = 0.9×max{0,  0.4}
           = 0.36

 由r2得到：
    CF2(H) = CF(H, E2)×max{ 0,  CF(E2) }
      　   = 0.6×max{ 0,  0.8 }
           = 0.48
由r3得到：
    CF3(H) = CF(H, E3)×max{ 0,  CF(E3) }
      　   = -0.5×max{ 0,  0.6 }
      　   = -0.3
```
根据结论不精确性的合成算法，CF1(H)和CF2(H)同号，有：

![](https://i.loli.net/2019/02/24/5c71730073a87.jpg)

CF12(H)和CF3(H)异号，有：

![](https://i.loli.net/2019/02/24/5c717300b3a3f.jpg)

综合可信度为CF(H)=0.53。

---

### 证据理论(ppt-25-21)


## 专家系统

>专家系统的先行者费根鲍姆（Feigenbaum）曾把专家系统定义为一个应用知识和推理过程来求解那些需要大量的人类专家解决难题经验的智能计算机程序。
>专家系统主要指的是一个智能计算机程序系统，其内部含有大量的某个领域专家水平的知识与经验，能够利用人类专家的知识和解决问题的经验方法来处理该领域的高水平难题。

### 专家系统概述
* 专家系统是一个具有大量的专门知识与经验的程序系统，它应用人工智能技术和计算机技术，根据某领域一个或多个专家提供的知识和经验，进行推理和判断，模拟人类专家的决策过程，以便解决那些需要人类专家才能处理好的复杂问题。简而言之，专家系统是一种模拟人类专家解决领域问题的计算机程序系统。
* 专家系统的基本功能取决于它所含有的知识，因此，有时也把专家系统称为基于知识的系统（knowledge-based system）。

#### 专家系统的特点
* 启发性
    - 专家系统要解决的问题，其结构往往是不合理的，其问题求解（problem-solving）知识不仅包括理论知识和常识，而且包括专家本人的启发知识。
    - 能运用专家的知识和经验进行推理、判断和决策。
* 透明性
    - 专家系统能够解释本身的推理过程和回答用户提出的问题，以便让用户了解推理过程，提高对专家系统的信赖感。
    - 问题求解过程中知识应用的合理性可由检验专家系统的解释推理路径来验证。
* 灵活性
    - 专家系统的灵活性是指它的扩展和丰富知识库的能力，以及改善非编程状态下的系统性能，即自学习能力。
    - 专家系统能不断增长知识，修改原有知识，不断更新

#### 专家系统的优点
* 专家系统能够高效率、准确、周到、迅速和不知疲倦地进行工作。
* 专家系统解决实际问题时不受周围环境的影响，也不可能遗漏和忘记。
* 可以使专家的专长不受时间和空间的限制，以便推广珍贵和稀缺的专家知识与经验。
* 专家系统能促进各领域的发展，使各领域专家的专业知识和经验得到总结和精炼，能够广泛有力地传播专家的知识、经验和能力。
* 专家系统能汇集多领域专家的知识和经验以及他们协作解决重大问题的能力，它拥有更渊博的知识、更丰富的经验和更强的工作能力。
* 军事专家系统的水平是一个国家国防现代化的重要标志之一。
* 专家系统的研制和应用，具有巨大的经济效益和社会效益。
* 研究专家系统能够促进整个科学技术的发展。专家系统对人工智能各个领域的发展起了很大的促进作用，并将对科技、经济、国防、教育、社会和人民生活产生极其深远的影响。

#### 专家系统的结构

* 专家系统简化结构图

![](https://i.loli.net/2019/02/24/5c71746ca090b.jpg)

* 理想专家系统的结构图

![](https://i.loli.net/2019/02/24/5c71746d0baad.jpg)

* 专家系统的主要组成部分：
    - 知识库
    - 综合数据库
    - 推理机
    - 解释器
    - 接口

#### 专家系统的建造步骤
* 设计初始知识库
    - 问题知识化
    - 知识概念化
    - 概念形式化
    - 形式规则化
    - 规则合法化
* 原型机（prototype）的开发与实验
* 知识库的改进与归纳

![](https://i.loli.net/2019/02/24/5c71746cc7305.jpg)

### 基于规则的专家系统基于框架的专家系统

一个基于规则的专家系统采用下列模块来建立产生式系统的模型：
1. 知识库：以一套规则建立人的长期存储器模型。
2. 工作存储器：建立人的短期存储器模型，存放问题事实和由规则激发而推断出的新事实。
3. 推理机：借助于把存放在工作存储器内的问题事实和存放在知识库内的规则结合起来，建立人的推理模型，以推断出新的信息 。

### 基于框架的专家系统

* 基于框架的专家系统是一个计算机程序，该程序使用一组包含在知识库内的框架对工作存储器内的具体问题信息进行处理，通过推理机推断出新的信息。
* 基于框架的专家系统是建立在框架的基础之上的。一般概念存放在框架内，而该概念的一些特例则被表示在其他框架内并含有实际的特征值。
* 基于框架的专家系统能够提供基于规则专家系统所没有的特征，如继承、侧面、信息通信和模式匹配规则等，因而，基于框架的专家系统比基于规则的专家系统拥有更强的功能，适用于解决更复杂的问题。

### 基于模型的专家系统

* 关于人工智能的一个观点:  认为人工智能是对各种定性模型（物理的、感知的、认识的和社会的系统模型）的获得、表达及使用的计算方法进行研究的学问。一个知识系统中的知识库是由各种模型综合而成的。
* 模型类型：基于逻辑的心理模型、定性的物理模型、神经元网络模型、可视知识模型等等。
* 综合各种模型的专家系统比基于逻辑心理模型的系统具有更强的功能，从而有可能显著改进专家系统的设计
* 在诸多模型中，人工神经网络模型的应用最为广泛

### 基于Web的专家系统
### 新型专家系统
以上部分专家系统就不详叙了。

---
## 模糊逻辑系统
### 模糊逻辑原理

模糊逻辑的发展，是由理论准备到理论提出再到理论应用的过程

![](https://i.loli.net/2019/02/24/5c717cc8eb13c.jpg)

### 模糊集
* 从精确到模糊
    - 精确
        + 答案确定：要么是，要么不是
        + `f : A → {0,1}`
        + 如：他是学生？不是学生？
    - 模糊
        + 答案不定：也许是，也许不是，也许介于之间
        + `μA : U → [0,1]`
        + 如：他是成年人？不是成年人？大概是成年人？

---

【例子】表示“20岁左右”
* 原集合（年龄）
    - {...., 17, 18, 19, 20, 21, 22, 23, ...}
* 模糊集可以表示为：
    - 0.8/18 + 0.9/19 + 1/20 + 0.9/21 + 0.8/12
    - 0.6/17+0.7/18+0.8/19+1/20+0.9/21+0.7/22+0.6/23

---

#### 集合及其特征函数
* 在论域中，把具有某种属性的事物的全体称为集合。由于集合中的元素都具有某种属性，因此可以用集合表示某一种概念，而且可用一个函数来刻画它，该函数称为特征函数。
* 设A是论域U上的一个集合，对任意u∈U，令

![](https://i.loli.net/2019/02/24/5c717d04126ba.jpg)

* 则称CA(u)为集合A的特征函数。特征函数CA(u)在u=u0处的取值CA(u0)称为u0对A的隶属度。
* 集合A与其特征函数可以认为是等价的：A={u |CA(u)=1}

#### 模糊集与隶属函数
* 模糊集把特征函数的取值范围从{0,1}推广到[0,1]上。
* 设U是论域，μA是把任意u∈U映射为[0,1]上某个值的函数，即
`μA : U→[0,1]   或   u→μA(u)`
* 则称μA为定义在U上的一个隶属函数，由μA(u)(u∈U)所构成的集合A称为U上的一个模糊集，μA(u)称为u对A的隶属度。

---

【例子】
论域U={1,2,3,4,5}，用模糊集表示“大”和“小”。

解：设A、B分别表示“大”与“小”的模糊集，μA ，μB分别为相应的隶属函数。
`A = {0, 0, 0.1, 0.6, 1}`
`B = {1, 0.5, 0.01, 0, 0}`
其中：
`μA(1)=0, μA(2)=0 , μA(3)=0.1 , μA(4)=0.6 , μA(5)=1`
`μB(1)=1, μB(2)=0.5 , μB(3)=0.01 , μB(4)=0, μB(5)=0`

---

#### 模糊集的表示方法
(1)、论域离散且为有限
若论域 U={u1, … , un}为离散论域，模糊集A表示为：
`A= {μA(u1), μA(u2), … ,  μA(un)}`
也可写为：
`A= μA(u1)/u1 + μA(u2)/u2 + … + μA(un)/un`
其中，隶属度为0的元素可以不写。

例如：
```
A = 1/u1+0.7/u2+0/u3+0.4/u4
  = 1/u1+0.7/u2+0.4/u4
```

(2)、论域连续
若论域是连续的，则模糊集可用实函数表示。

![](https://i.loli.net/2019/02/24/5c717d041d888.jpg)

例如：以年龄为论域U=[0,100]， “年轻”和“年老”这两个概念可表示为：

![](https://i.loli.net/2019/02/24/5c717d042113c.jpg)

(3)、一般表示方法
不管论域 U 是有限的还是无限的，是连续的亦或是离散的，扎德（ L. A. Zadeh ）又给出了一种类似于积分的一般表示形式：

![](https://i.loli.net/2019/02/24/5c717d04140b2.jpg)

这里的记号不是数学中的积分符号，也不是求和，只是表示论域中各元素与其隶属度对应关系的总括。

#### 模糊集的运算
* 模糊集的包含运算
    - 设A、B分别是U 上的两个模糊集，对任意u∈U，都有 μB(u) ≤ μA(u) 成立，则称A包含B，记为B≤A。
* 模糊集的交、并、补运算
    - 设A、B分别是U上的两个模糊集，则A和B两个集合的并集A∪B、交集A∩B和A的补集﹁A的隶属函数分别为：

![](https://i.loli.net/2019/02/24/5c717d043ac6a.jpg)

---

【例子】
设U={u1,u2,u3}，
A=0.3/u1+0.8/u2+0.6/u3;    B=0.6/u1+0.4/u2+0.7/u3
求A∩B，A∪B和¬A。
```
A∩B = (0.3∧0.6)/u1+(0.8∧0.4)/u2+(0.6∧0.7)/u3
    = 0.3/u1+0.4/u2+0.6/u3
A∪B = (0.3∨0.6)/u1+(0.8∨0.4)/u2+(0.6∨0.7)/u3
    = 0.6/u1+0.8/u2+0.7/u3
¬A  = (1-0.3)/u1+(1-0.8)/u2+(1-0.6)/u3
    = 0.7/u1+0.2/u2+0.4/u3
```

---

### 模糊关系
#### 模糊关系的定义
* 设 Ai 是 Ui (i=1,2,…,n) 上的模糊集，则称![](https://i.loli.net/2019/02/24/5c717d76c6501.jpg)为A1, A2, …, An的笛卡尔乘积，它是U1×U2×…×Un上的一个模糊集。

* 在U1×…×Un上一个n元模糊关系R是指以U1×…×Un为论域的一个模糊集，记为:
![](https://i.loli.net/2019/02/24/5c717d9ecfa10.jpg)

一般地说，当U和V都是有限论域时，`U={u1,u2,…,um}`，`V={v1,v2,…,vn}`，则U×V上的模糊关系R可用一个模糊矩阵表示
![](https://i.loli.net/2019/02/24/5c717d9ee3711.jpg)

##### 模糊关系的合成
* 设R1与R2分别是U×V与V×W上的两个模糊关系，则R1与R2的合成是指从U到W的一个模糊关系，记为`R1°R2`
* 其隶属函数为
![](https://i.loli.net/2019/02/24/5c717deb739dc.jpg)
* 隶属函数计算方法：取R1的第 i 行元素分别与R2的第 j 列元素相比较，两个数中取其小者，然后再在所得的一组最小数中取最大的一个，以此作为R1°R2的第 i 行第 j 列的元素。

---

【例子】
设有两个模糊关系
![](https://i.loli.net/2019/02/24/5c717e07cc3e0.jpg)
则R1与R2的合成是
![](https://i.loli.net/2019/02/24/5c717e07d34eb.jpg)


---

### 模糊变换

#### 模糊变换的概念
设`A={μA(u1),μA(u2),…,μA(un)}`是论域U上的模糊集，R是`U×V`上的模糊关系，则`A°R = B`称为模糊变换。

例如：设A={0.2,0.5,0.3}
![](https://i.loli.net/2019/02/24/5c717e5e3cbf8.jpg)

#### 用模糊变换可进行模糊推理
例如：设对某厨师做的一道菜进行评判
评判标准是：色（u1）、香（u2） 、味（u3），它们构成论域：U= { u1, u2 , u3}。
评判时由评委对每一个评判因素分别进行打分，评判等级是好（v1）、较好（v2） 、一般（v3）、差（v4），它们构成论域：V= {v1, v2 , v3 , v4}。
仅就色而言，有60%的评委认为这道菜“好”， 20%的评委认为 “较好”，20%的评委认为 “一般”，没有评委认为 “差”，则对“色”的评价为：{0.6 , 0.2, 0.2, 0}
对“香”的评价为：{0.8 , 0.1, 0.1, 0}
对“味”的评价为：{0.3 , 0.3, 0.3, 0.1}
这样就可以写出矩阵R：
![](https://i.loli.net/2019/02/24/5c717e8a1c5bd.jpg)
假设三个评判因素在评判中所占的权重分别是：“色”为0.3，“香”为0.3，“味”为0.4。这三个权重组成了U上的一个模糊向量：A={0.3 , 0.3, 0.4}
由此可得到评委对这道菜的综合评判为：
![](https://i.loli.net/2019/02/24/5c717e8a29f94.jpg)
在此例中，评判结果的各项和刚好为1，所以它就是最终评判结果。
如果不是这样，还需要对其进行归一化处理，将归一化后的结果作为最终评判结果。

### 模糊推理

#### 简单模糊推理(扎德法)
>知识中只含有简单条件，且不带可信度因子的模糊推理称为简单模糊推理。
>关于如何由已知的模糊知识和证据具体地推出模糊结论，目前已经提出了多种推理方法。其中包括扎德（ L. A. Zadeh ）等人提出的合成推理规则。

扎德：基于模糊关系合成推理的基本思想
* 对于知识 “`IF x is A  THEN y is B`”，首先构造出A与B之间的模糊关系R；
* 再将R与证据合成，求出结论。

*合成推理规则*：
对于知识`IF x is A  THEN y is B`
* 首先构造出A与B之间的模糊关系R，然后通过R与证据的合成求出结论。
* 如果已知证据是` x is A’`，且A与A’可以模糊匹配，则通过下述合成运算求取B'：
`B'= A’ ◦R`
* 如果已知证据是` y is B'`，且B与B'可以模糊匹配，则通过下述合成运算求出A’：
` A’ =R◦B'`

至于如何构造模糊关系R：
>条件命题的极大极小规则：记获得的模糊关系为Rm

设`A∈F(U)`, `B∈F(V)`，其表示分别为
![](https://i.loli.net/2019/02/24/5c717eb0efe4c.jpg)
扎德把Rm定义为：
![](https://i.loli.net/2019/02/24/5c717eb0f1776.jpg)

---

【例子】
设`U=V={1,2,3,4,5}`, `A=1/1+0.5/2`, `B=0.4/3+0.6/4+1/5`
并设模糊知识为：`IF  x is A  THEN  y is B `
模糊证据为：`x is A’`
其中， A’的模糊集为： `A’ =1/1+0.4/2+0.2/3`

则：由模糊知识可得到 Rm
![](https://i.loli.net/2019/02/24/5c717ecf19ec3.jpg)

求B'：B'= A’ ◦R
![](https://i.loli.net/2019/02/24/5c717ecf3a49b.jpg)

若已知证据为: y is B'
`B'=0.2/1+0.4/2+0.6/3+0.5/4 +0.3/5`
则：![](https://i.loli.net/2019/02/24/5c717ecf55dcc.jpg)

---


### 模糊计算的流程
#### 模糊计算适用
1. 复杂且没有完整数学模型的非线性问题：可在不知晓具体模型的情况下利用经验规则求解；
2. 与其它智能算法结合实现优势互补: 提供了将人类在识别、决策、理解等方面的模糊性引入机器及其控制的途径。

#### 模糊计算的过程
* 模糊规则库：
    - 是专家提供的模糊规则。
* 模糊化：
    - 是根据隶属度函数从具体的输入得到对模糊集隶属度的过程。
* 推理方法：
    - 是从模糊规则和输入对相关模糊集的隶属度得到模糊结论的方法。
* 去模糊化：
    - 就是将模糊结论转化为具体的、精确的输出的过程。

#### 模糊计算的一般流程：
![](https://i.loli.net/2019/02/24/5c717ecf6090f.jpg)

## 神经网络系统
### 人工神经网络概述

人工智能的各种学说
* 符号（功能）主义：符号逻辑推理
* 联结（结构）主义：人工神经网络
* 行为主义：智能行为模拟， “模式-动作”
联结主义的观点：智能的寓所在大脑皮层，它由大量非线性神经元互联而成 **并行处理**的神经网络。
![](https://i.loli.net/2019/02/24/5c717f0d881df.jpg)

对比这几种模拟方法：
```
神经网络：是一种对人类智能的结构模拟方法，它是通过对大量人工神经元的广泛并行互联，构造人工神经网络系统去模拟生物神经系统的智能机理的。
进化计算：是一种对人类智能的演化模拟方法，它是通过对生物遗传和演化过程的认识，用进化算法去模拟人类智能的进化规律的。
模糊计算：是一种对人类智能的逻辑模拟方法，它是通过对人类处理模糊现象的认知能力的认识，用模糊逻辑去模拟人类的智能行为的。
```

* 人工神经网络（ANN）是反映人脑结构及功能的一种抽象数学模型，是由大量神经元节点互连而成的复杂网络，用以模拟人类进行知识的表示与存储以及利用知识进行推理的行为。
* 简单地讲，它是一个数学模型，可以用电子线路来实现，也可以用计算机程序来模拟，是人工智能研究的一种方法。
* 人工神经网络力求从四个方面模拟人脑的智能行为： 物理结构，计算模拟，存储与操作，训练

### 人工神经网络的特性
* 并行分布处理：并行结构，耐故障；
* 非线性映射：任意非线性映射能力；
* 通过训练进行学习：通过数据记录进行训练，能处理由数学模型或描述规则难以处理的问题；
* 适应与集成：自适应和信息融合能力；
* 硬件实现：快速和大规模处理能力。

### 人工神经元模型
MP模型是美国心理学家麦克洛奇(W.McM  ulloch)和数理逻辑学家皮茨(W.Pitts) 根据生物神经元的功能和结构，于1943年提出的一种将神经元看作二进制阈值元件的简单模型。MP模型是大多数神经网络模型的基础。
MP模型示意图：
![](https://i.loli.net/2019/02/24/5c717f557f98f.jpg)
* 人工神经元是仿照生物神经元提出的，神经元可以有N个输入：
`x1,x2,x3,...,xN`
* 每个输入端与神经元之间有一定的联接权值：
`w1,w2,w3,...,wN`
* 神经元总的输入为对每个输入的加权求和，同时减去阈值θ。u代表神经元的活跃值，即神经元状态：
![](https://i.loli.net/2019/02/24/5c717f5581682.jpg)
* 神经元的输出y是对u的映射：
![](https://i.loli.net/2019/02/24/5c717f55892f1.jpg)
* f 称为输出函数（激励函数，激活函数），可以有很多形式：
![](https://i.loli.net/2019/02/24/5c717f55bdd0b.jpg)

输出函数的作用
* 控制输入对输出的激活作用
* 对输入、输出进行函数转换
* 将可能无限域的输入变换成指定的有限范围内的输出

* 神经元的模型确定之后，一个神经网络的特性及能力主要取决于网络的拓扑结构及学习方法
* 人工神经网络（ANN）可以看成是以人工神经元为结点，用有向加权弧连接起来的有向图
    - 人工神经元就是对生物神经元的模拟
    - 有向弧则是轴突—突触—树突对的模拟
    - 有向弧的权值表示相互连接的两个人工神经元间相互作用的强弱。

### 人工神经网络的分类
![](https://i.loli.net/2019/02/24/5c717f55c706d.jpg)
人工神经网络模型是指对网络结构、联结权值和学习能力的总括。常用的网络模型已有数十种。例如：
传统的感知机模型；具有误差反向传播功能的反向传播网络模型；采用多变量插值的径向基函数网络模型；建立在统计学习理论基础上的支撑向量机网络模型；采用反馈联接方式的反馈网络模型；基于模拟退火算法的随机网络模型。

>前馈网络

#### 单层前馈网络
单层前馈网络是指那种只拥有单层计算节点的前向网络。它仅含有输入层和输出层，且只有输出层的神经元是可计算节点。
![](https://i.loli.net/2019/02/24/5c717f55ced12.jpg)
其中，输入向量为X=(x1,x2,…,xn)；输出向量为Y=(y1,y2,…,ym)；输入层各个输入到相应神经元的连接权值分别是wij，i=1,2,..,n，j=1,2,.., m。
若假设各神经元的阈值分别是θj，j=1,2,…,m，则各神经元的输出yj, j=1,2,..,m分别为：
![](https://i.loli.net/2019/02/24/5c717fc28c821.jpg)
其中，由所有连接权值wij构成的连接权值矩阵W为：
![](https://i.loli.net/2019/02/24/5c717fc292138.jpg)
在实际应用中，该矩阵是通过大量的训练示例学习而形成的。

#### 多层前馈网络
多层前馈网络是指那种除拥有输入、输出层外，还至少含有一个、或更多个隐含层的前馈网络。典型代表：BP网络。
![](https://i.loli.net/2019/02/24/5c717fc2e39b5.jpg)
隐含层作用：通过对输入层信号的加权处理，将其转移成更能被输出层接受的形式。

>反馈网络

反馈网络是指允许采用反馈联结方式所形成的神经网络。反馈联结方式：是指一个神经元的输出可以被反馈至同层或前层的神经元。典型代表：Hopfield网络。

#### 前馈网络与反馈网络的区别
* 前馈网络：非循环连接模式，每个神经元的输入都没有包含该神经元先前的输出，因此不具有“短期记忆”的性质。
* 反馈网络：每个神经元的输入都有可能包含有该神经元先前输出的反馈信息，这就有点类似于人类的短期记忆的性质。

### 传统的感知器模型
>感知器是美国学者罗森勃拉特（Rosenblatt）于1957年为研究大脑的存储、学习和认知过程而提出的一类具有自学习能力的神经网络模型，其拓扑结构是一种分层前向网络。包括：单层感知器和多层感知器。

使用感知器的主要目的是 **为了对外部输入进行分类**。
罗森勃拉特已经证明，如果外部输入是线性可分的（指存在一个超平面可以将它们分开），则单层感知器一定能够把它划分为两类。其判别超平面由如下判别式确定：
![](https://i.loli.net/2019/02/24/5c718058bf8bc.jpg)
作为例子，下面讨论用单个感知器实现逻辑运算的问题。

#### 单层感知器
单层感知器是一种只具有单层可调节连接权值神经元的前向网络，这些神经元构成了单层感知器的输出层，是感知器的可计算节点。
* 在单层感知器中，每个可计算节点都是一个线性阈值神经元。当输入信息的加权和大于或等于阈值时，输出为1，否则输出为0或-1。
* 单层感知器的输出层的每个神经元都只有一个输出，且该输出仅与本神经元的输入及联接权值有关，而与其他神经元无关。
* 单层感知器可以很好地实现“与”、“或”、“非”运算，但却 **不能解决“异或”问题**。
![](https://i.loli.net/2019/02/24/5c71811825fda.jpg)

#### 多层感知器
多层感知器是通过在单层感知器的输入、输出层之间加入一层或多层处理单元所构成的。
* 拓扑结构与多层前馈网络相似，差别在于其计算节点的连接权值是可变的。
* 输入与输出呈现高度非线性的映射关系。

### BP网络模型
>误差反向传播(Error Back Propagation)网络简称为BP网络，是由美国加州大学的鲁梅尔哈特和麦克莱兰于1985年提出的一种网络模型。

在BP网络中，同层节点之间不存在相互连接，层与层之间多采用全互连方式，且各层的连接权值可调。BP网络实现了明斯基的多层网络的设想，是当今神经网络模型中使用最广泛的一种。
![](https://i.loli.net/2019/02/24/5c7181181ddcc.jpg)
如上图所示，BP网络的网络拓扑结构是多层前向网络。

对BP网络需说明以下两点：
第一，BP网络的每个处理单元均为非线性输入/输出关系，其作用函数通常采用的是可微的Sigmoid函数，如：
！[](https://i.loli.net/2019/02/24/5c7181177b6c6.jpg)
第二，BP网络的学习过程是由工作信号的正向传播和误差信号的反向传播组成的。所谓正向传播，是指输入模式经隐层到输出层，最后形成输出模式；所谓误差反向传播，是指从输出层开始逐层将误差传到输入层，并修改各层联接权值，使误差信号为最小的过程。


### BP网络模型
>Hopfield网络是由美国加州工学院物理学家霍普菲尔特1982年提出来的一种单层全互连的对称反馈网络模型。分为离散Hopfield网络和连续Hopfield网络。

离散Hopfield网络是在非线性动力学的基础上由若干基本神经元构成的一种单层全互连网络，其任意神经元之间均有连接，并且是一种对称连接结构。
离散Hopfield网络模型是一个离散时间系统，每个神经元只有0和1（或-1和1）两种状态，任意神经元i和j之间的连接权值为Wij。由于神经元之间为对称连接，且神经元自身无连接，因此有
![](https://i.loli.net/2019/02/24/5c7181178fc99.jpg)
由该连接权值所构成的连接矩阵是一个零对角的对称矩阵。

在 Hopfield网络中，虽然神经元自身无连接，但由于每个神经元都与其他神经元相连，即每个神经元的输出都将通过突触连接权值传递给别的神经元，同时每个神经元又都接受其他神经元传来的信息，这样对每个神经元来说，其输出经过其他神经元后又有可能反馈给自己，因此Hopfidld网络是一种反馈神经网络 。

---

【例子】
已知网络结构如图所示，网络输入输出路标所示。其中，f(x)为x的符号函数![](https://i.loli.net/2019/02/24/5c71811791800.jpg)，bias取常数1，设初始值随机取成(0.75,0.5,-0.6)。利用误差传播学习算法调整神经网络权值。
![](https://i.loli.net/2019/02/24/5c71811823ac3.jpg)

解题过程：
![](https://i.loli.net/2019/02/24/5c718118556a9.jpg)

---


## 机器学习系统
### 机器学习的基本概念
* 机器学习是人工智能的核心，通过使机器模拟人类学习行为，智能化地从过去的经历中获得经验，从而改善其整体性能，重组内在知识结构，并对未知事件进行准确的推断。
* 机器学习在科学和工程诸多领域都有着非常广泛的应用，例如金融分析、数据挖掘、生物信息学、医学诊断等。生活中常见的一些智能系统也广泛使用机器学习算法，例如电子商务、手写输入、邮件过滤等。

>机器学习的定义:
>西蒙（Simon,1983）：学习就是系统中的适应性变化，这种变化使系统在重复同样工作或类似工作时，能够做得更好。
>
>明斯基（Minsky,1985）：学习是在人们头脑里（心理内部）有用的变化。
>
>学习是一个有特定目的知识获取和能力增长过程，其内在行为是获得知识、积累经验、发现规律等，其外部表现是改进性能、适应环境、实现自我完善等。
>
>机器学习是研究如何使用机器来模拟人类学习活动的一门学科。

进入21世纪，机器学习的阶段研究热点：
2000-2006年的流形学习、2006-2011年的稀疏学习、2012年-至今的深度学习、未来：迁移学习？

### 机器学习与深度学习的关系
* **机器学习是一种实现人工智能的方法，深度学习是一种实现机器学习的技术**。深度学习本来并不是一种独立的学习方法，其本身也会用到监督和无监督的学习方法来训练深度神经网络。
* 最初的深度学习是利用深度神经网络来解决特征表达的一种学习过程。

提一下，深度学习目前存在以下问题
1. 深度学习模型需要大量的训练数据，才能展现出神奇的效果，但现实生活中往往会遇到小样本问题，此时深度学习方法无法下手，传统的机器学习方法就可以处理。
2. 有些领域，采用传统的简单的机器学习方法，可以很好地解决了，没必要非得用复杂的深度学习方法。
3. 深度学习的思想，来源于人脑的启发，但绝不是人脑的模拟。举个例子，一个三岁的小孩看一辆自行车之后，再见到哪怕外观完全不同的自行车，小孩也十有八九就能做出那是一辆自行车的判断，也就是说，人类的学习过程往往不需要大规模的训练数据，而现在的深度学习方法显然不是对人脑的模拟。

### 机器学习策略与基本结构
#### 机器学习的主要策略
* 按照学习中使用推理的多少，机器学习所采用的策略大体上可分为4种：
    - 机械学习：记忆学习方法，即把新的知识存储起来，供需要时检索调用，而不需要计算和推理。
    - 示教学习：外界输入知识与内部知识的表达不完全一致，系统在接受外部知识时需要推理、翻译和转化。
    - 类比学习：需要发现当前任务与已知知识的相似之处，通过类比给出完成当前任务的方案。
    - 示例学习：需要从一组正例和反例中分析和总结出一般性的规律，在新的任务中推广、验证、修改规律。

#### 学习系统的基本结构
![](https://i.loli.net/2019/02/24/5c718197adb27.jpg)

* 影响学习系统设计的要素
    - 环境：环境向系统提供信息的水平（一般化程度）和质量（正确性）
    - 知识库：表达能力，易于推理，容易修改，知识表示易于扩展。

### 归纳学习
* 归纳学习是应用归纳推理进行学习的一种方法。
* 归纳学习的模式：
![](https://i.loli.net/2019/02/24/5c718197b3bbf.jpg)
实验规划过程通过对实例空间的搜索完成实例选择，并将这些选中拿到的活跃实例提交给解释过程。解释过程对实例加以适当转换，把活跃实例变换为规则空间中的特定概念，以引导规则空间的搜索。

* 归纳学习是目前研究得最多的学习方法，其学习目的是为了获得新概念、构造新规则或发现新理论。
* 根据归纳学习有无教师指导，可把它分为
    - 示例学习：给学习者提供某一概念的一组正例和反例，学习者归纳出一个总的概念描述（规则），并使这个描述适合于所有的正例，排除所有的反例。
    - 观察发现学习：
        + 概念聚类：按照一定的方式和准则分组，归纳概念
        + 机器发现：从数据和事例中发现新知识

### 类比学习
* 类比学习（learning by analogy）就是通过类比，即通过对相似事物加以比较所进行的一种学习 。
* 类比学习是利用二个不同领域（源域、目标域）中的知识相似性，可以通过类比，从源域的知识（包括相似的特征和其它性质）推导出目标域的相应知识，从而实现学习。例如：
    - 一个从未开过truck的司机，只要他有开car的知识就可完成开truck的任务。
    - 若把某个人比喻为消防车，则可通过观察消防车的行为，推断出这个人的性格。
* 类比学习系统可以使一个已有的计算机应用系统转变为适应于新的领域，来完成原先没有设计的相类似的功能。
* 类比推理过程：
    - 回忆与联想：找出当前情况的相似情况
    - 选择：选择最相似的情况及相关知识
    - 建立对应关系：建立相似元素之间的映射
    - 转换：求解问题或产生新的知识

* 类比学习研究类型
    - 问题求解型的类比学习：求解一个新问题时，先回忆以前是否求解过类似问题，若是，则以此为依据求解新问题。
    - 预测推理型的类比学习
        + 传统的类比法：用来推断一个不完全确定的事物可能还有的其他属性
        + 因果关系型：已知因果关系`S1:A->B`，如果有`A'≌A`，则可能有B'满足`A'->B'`

### 解释学习
>解释学习(Explanation-based learning, EBL)兴起于20世纪80年代中期，根据任务所在领域知识和正在学习的概念知识，对当前实例进行分析和求解，得出一个表征求解过程的因果解释树，以获取新的知识。
>例如：学生根据教师提供的目标概念、该概念的一个例子、领域理论及可操作准则，首先构造一个解释来说明为什么该例子满足目标概念，然后将解释推广为目标概念的一个满足可操作准则的充分条件。

解释学习过程和算法
米切尔提出了一个解释学习的统一算法EBG，建立了基于解释的概括过程，并用知识的逻辑表示和演绎推理进行问题求解。其一般性描述为：
* 给定：领域知识DT、目标概念TC、训练实例TE、操作性准则OC
* 找出：满足OC的关于TC的充分条件
![](https://i.loli.net/2019/02/24/5c7182479a4b4.jpg)

EBG算法可概括为两步：
1. 构造解释：运用领域知识进行演绎，证明提供给系统的训练实例为什么是满足目标概念的一个实例。
2. 获取一般性的知识：
    - 任务：对上一步得到的解释结构进行一般化的处理，从而得到关于目标概念的一般性知识。
    - 方法：将常量换成变量，并把某些不重要的信息去掉，只保留求解问题必须的关键信息。

### 神经网络学习(ppt-21-32)

#### Hebb学习
#### 纠错学习
#### 竞争学习及随机学习
#### 感知器学习

单层感知器学习算法可描述如下：
(1)、设t=0，初始化连接权和阈值。即给wi(0)(i=1, 2, … ,n)及θ(0)分别赋予一个较小的非零随机数，作为初值。其中，wi(0)是第0次迭代时输入向量中第i个输入的连接权值；θ(0)是第0次迭代时输出节点的阈值；
(2)、提供新的样本输入xi(t)(i=1, 2, … , n)和期望输出d(t)；
(3)、计算网络的实际输出：
![](https://i.loli.net/2019/02/24/5c718197b9052.jpg)
(4)、若y(t)=d(t)，不需要调整连接权值，转(6)。否则，需要调整权值；
(5)、调整连接权值；
![](https://i.loli.net/2019/02/24/5c718197bbddb.jpg)
其中，η是一个增益因子，用于控制修改速度，其值如果太大，会影响wi(t)的收敛性；如果太小，又会使wi(t)的收敛速度太慢;
(6)、判断是否满足结束条件，若满足，算法结束；否则，将t值加1，转(2)重新执行。这里的结束条件一般是指wi(t)对一切样本均稳定不变。
若输入的两类样本是线性可分的，则该算法就一定会收敛。否则，不收敛。

---

【例子】用单层感知器实现逻辑“与”运算。

解：根据“与”运算的逻辑关系，可将问题转换为：
输入向量：
`X1=[0, 0, 1, 1]`
`X2=[0, 1, 0, 1]`
输出向量：
`Y=[0, 0, 0, 1]`
为减少算法的迭代次数，设初始连接权值和阈值取值如下：
`w1(0)=0.5`,   `w2(0)=0.7`,   `θ(0)=0.6`
并取增益因子`η=0.4`。

算法的学习过程如下：
设两个输入为`x1(0)=0`和`x2(0)=0`，其期望输出为`d(0)=0`，实际输出为：
```
y(0)=f(w1(0)x1(0)+ w2(0)x2(0)-θ(0))
    =f(0.5*0+0.7*0-0.6)
    =f(-0.6)
    =0
```
实际输出与期望输出相同，不需要调节权值。
再取下一组输入：`x1(0)=0`和`x2(0)=1`，期望输出`d(0)=0`，实际输出：
```
y(0)=f(w1(0) x1(0)+ w2(0) x2(0)-θ(0))
    =f(0.5*0+0.7*1-0.6)
    =f(0.1)
    =1
```
实际输出与期望输出不同，需要调节权值，其调整如下：
```
θ(1)=θ(0)+η(d(0)- y(0))*(-1)=0.6+0.4*(0-1)*(-1)=1
w1(1)=w1(0)+η(d(0)- y(0))x1(0)=0.5+0.4*(0-1)*0=0.5
w2(1)=w2(0)+η(d(0)- y(0))x2(0)=0.7+0.4*(0-1)*1=0.3
```
取下一组输入：`x1(1)=1`和`x2(1)=0`，其期望输出为`d(1)=0`，实际输出为：
```
y(1)=f(w1(1) x1(1)+ w2(1) x2(1)-θ(1))
      =f(0.5*1+0.3*0-1)
      =f(-0.51)
      =0
```
实际输出与期望输出相同，不需要调节权值。
再取下一组输入：`x1(1)=1和x2(1)=1`，其期望输出为`d(1)=1`，实际输出为：
```
y(1)=f(w1(1) x1(1)+ w2(1) x2(1)-θ(1))
    =f(0.5*1+0.3*1-1)
    =f(-0.2)
    =0
```
实际输出与期望输出不同，需要调节权值，其调整如下：
```
θ(2)=θ(1)+η(d(1)- y(1))*(-1)=1+0.4*(1-0)*(-1)=0.6
w1(2)=w1(1)+η(d(1)- y(1))x1(1)=0.5+0.4*(1-0)*1=0.9
w2(2)=w2(1)+η(d(1)- y(1))x2(1)=0.3+0.4*(1-0)*1=0.7
```
取下一组输入：`x1(2)=0`和`x2(2)=0`，其期望输出为`d(2)=0`，实际输出为：
`y(2)=f(0.9*0+0.7*0-0.6)=f(-0.6)=0`
实际输出与期望输出相同，不需要调节权值.
再取下一组输入：`x1(2)=0`和`x2(2)=1`，期望输出为`d(2)=0`，实际输出为：
`y(2)=f(0.9*0+0.7*1-0.6)=f(0.1)=1`
实际输出与期望输出不同，需要调节权值，其调整如下：
```
θ(3)=θ(2)+η(d(2)- y(2))*(-1)=0.6+0.4*(0-1)*(-1)=1
w1(3)=w1(2)+η(d(2)- y(2))x1(2)=0.9+0.4*(0-1)*0=0.9
w2(3)=w2(2)+η(d(2)- y(2))x2(2)=0.7+0.4*(0-1)*1=0.3
```
实际上，由与运算的阈值条件可知，此时的阈值和连接权值以满足结束条件，算法可以结束。
对此，可检验如下：
对输入：“0 0”有`y=f(0.9*0+0.3*0-1)=f(-1)=0`
对输入：“0 1”有`y=f(0.9*0+0.3*0.1-1)=f(-0.7)=0`
对输入：“1 0”有`y=f(0.9*1+0.3*0-1)=f(-0.1)=0`
对输入：“1 1”有`y=f(0.9*1+0.3*1-1)=f(0.2)=1`

---

多层感知器可以解决非线性可分问题，但其隐层神经元的期望输出却不易给出。
而单层感知器学习是一种有导师指导的学习过程，因此其学习算法无法直接用于多层感知器。
由于多层感知器和BP网络都属于前向网络，并能较好解决多层前馈网络的学习问题.
因此，可用BP学习来解决多层感知器学习问题。

#### BP网络学习
#### Hopfield网络学习

### 其他机器学习方法
* 迁移学习：将在先前任务中学到的知识或技能应用于一个新的任务或新的领域
* 增强机器学习：从变化环境中学习蕴含在环境中的知识
* 流形机器学习：把一组在高维空间中的数据在低维空间中重新表示
* 半监督机器学习：结合标记和非标记样本
* 多实例机器学习：一个对象可能同时有多个描述
* Ranking机器学习：获得关于检索中“喜欢”顺序的模型
* 数据流机器学习：从数据流中发现知识
* ……

相关的一些概念：决策树、 随机森林、逻辑回归、朴素贝叶斯、K最近临算法、马尔可夫……


## 仿生进化系统(GA)
>遗传算法最早由美国密西根大学的J. Holland 教授提出，起源于20世纪60年代对自然和人工自适应系统的研究。70年代，De Jong 基于遗传算法的思想在计算机上进行了大量的纯数值函数优化计算实验。在一系列研究工作的基础上，80年代由Goldberg进行归纳总结，形成了遗传算法的基本框架

### 遗传算法的定义
遗传算法（Genetic Algorithm, GA）是模拟生物在自然环境种的遗传和进化过程而形成的一种自适应全局优化概率搜索算法。

### 遗传算法的基本思想
是从初始种群出发，采用优胜劣汰、适者生存的自然法则选择个体，并通过杂交、变异来产生新一代种群，如此逐代进化，直到满足目标为止。

### 遗传算法的基本过程

>算法主要内容和基本步骤

(1) 选择编码策略，将问题搜索空间中每个可能的点用相应的编码策略表示出来，即形成染色体；
(2) 定义遗传策略，包括种群规模N，交叉、变异方法，以及选择概率Pr、交叉概率Pc、变异概率Pm等遗传参数；
(3) 令t=0，随机选择N个染色体初始化种群P(0)；
(4) 定义适应度函数f（f>0）；
(5) 计算P(t)中每个染色体的适应值；
(6) t=t+1；
(7) 运用选择算子，从P(t-1)中得到P(t)；
(8) 对P(t)中的每个染色体，按概率Pc参与交叉；
(9) 对染色体中的基因，以概率Pm参与变异运算；
(10) 判断群体性能是否满足预先设定的终止标准，若不满足则返回(5)。

>常用的遗传编码算法

* 霍兰德二进制码
    - 二进制编码是将原问题的结构变换为染色体的位串结构。在二进制编码中，首先要确定二进制字符串的长度    ，该长度与变量的定义域和所求问题的计算精度有关。
* 格雷编码（Gray Code）
    - 格雷编码是对二进制编码进行变换后所得到的一种编码方法。这种编码方法要求两个连续整数的编码之间只能有一个码位不同，其余码位都是完全相同的。它有效地解决了汉明悬崖问题。
* 实数编码
    - 实数编码是将每个个体的染色体都用某一范围的一个实数（浮点数）来表示，其编码长度等于该问题变量的个数。
    - 这种编码方法是将问题的解空间映射到实数空间上，然后在实数空间上进行遗传操作。由于实数编码使用的是变量的真实值，因此这种编码方法也叫做真值编码方法。
    - 实数编码适应于那种多维、高精度要求的连续函数优化问题。
* 字符编码

>适应度函数

适应度函数是一个用于对个体的适应性进行度量的函数。通常，一个个体的适应度值越大，它被遗传到下一代种群中的概率也就越大。

(1) 常用的适应度函数
* 原始适应度函数：直接将待求解问题的目标函数f(x)定义为遗传算法的适应度函数。
    - 优点：能够直接反映出待求解问题的最初求解目标
    - 缺点：是有可能出现适应度值为负的情况。
* 标准适应度函数
    - 在遗传算法中，一般要求适应度函数非负，并其适应度值越大越好。这就往往需要对原始适应函数进行某种变换，将其转换为标准的度量方式，以满足进化操作的要求，这样所得到的适应度函数被称为标准适应度函数。
(2) 适应度函数的加速变换
* 在某些情况下，需要对适应度函数进行加速速度。
* 适应度函数的加速变换有两种基本方法，即线性加速与非线性加速。

* **线性加速**
    - 线性加速的适应度函数的定义如下：
    - `f'(x)=αf(x)+β`
    - 其中，f(x)是加速转换前的适应度函数；f'(x)是加速转换后的适应度函数；α和β是转换系数,它们应满足如下条件：
        + 变化后得到的新的适应度函数平均值要等于原适应度函数的平均值。即
        ![](https://i.loli.net/2019/02/24/5c718197d1e7f.jpg)
        + 其中，`xi(i=1,…,n)`为当前代中的染色体。
        + 变换后所得到的新的种群个体所具有的最大适应度要等于其平均适应度的指数倍数。即有关系：
        ![](https://i.loli.net/2019/02/24/5c718197cc03b.jpg)
        + 式中，`xi(i=1,…,n)`为当前代中的染色体，M是指将当前的最大适应度放大为平均值的M倍。目的是通过M拉开不同染色体适应度值的差距。
* **非线性加速**
    - 幂函数变换方法
        + `f'(x)=f(x)k`
    - 指数变换方法
        + `f'(x)=exp(-βf(x))`

>基本遗传操作

(1)、选择操作
选择（Selection）操作是指根据选择概率按某种策略从当前种群中挑选出一定数目的个体，使它们能够有更多的机会被遗传到下一代中。
常用的选择策略:
* 比例选择
* 排序选择
* 竞技选择
    - 其中比例选择基本思想是：各个个体被选中的概率与其适应度大小成正比。
    - 常用的比例选择策略:轮盘赌选择、繁殖池选择
    - 轮盘赌选择
轮盘赌选择法又被称为转盘赌选择法或轮盘选择法。在这种方法中，个体被选中的概率取决于该个体的相对适应度。而相对适应度的定义为：
![](https://i.loli.net/2019/02/24/5c718197cdd40.jpg)
其中，P(xi)是个体xi的相对适应度，即个体xi被选中的概率；f(xi)是个体xi的原始适应度；是种群的累加适应度。

轮盘赌选择算法的基本思想是：根据每个个体的选择概率P(xi)将一个圆盘分成N个扇区，其中第i个扇区的中心角为：
![](https://i.loli.net/2019/02/24/5c718197d633d.jpg)
再设立一个移动指针，将圆盘的转动等价为指针的移动。选择时，假想转动圆盘，若静止时指针指向第i个扇区，则选择个体i。
从统计角度看，个体的适应度值越大，其对应的扇区的面积越大，被选中的可能性也越大。这种方法有点类似于发放奖品使用的轮盘，并带有某种赌博的意思，因此亦被称为轮盘赌选择。

(2)、交叉操作
* 交配重组是自然界中生物遗传进化的一个主要环节，也是遗传算法中产生新的个体的最主要方法。
* 交叉（Crossover）操作是指按照某种方式对选择的父代个体的染色体的部分基因进行交配重组，从而形成新的个体。
* 根据个体编码方法的不同，遗传算法中的交叉操作可分为二进制交叉和实值交叉两种类型。
    - 二进制交叉
    - 二进制交叉（Binary Valued Crossover）是指二进制编码情况下所采用的交叉操作，它主要包括单点交叉、两点交叉、多点交叉和均匀交叉等方法。
        + 单点交叉
            * 单点交叉也称简单交叉，它是先在两个父代个体的编码串中随机设定一个交叉点，然后对这两个父代个体交叉点前面或后面部分的基因进行交换，并生成子代中的两个新的个体。假设两个父代的个体串分别是：
            * `X=x1 x2 … xk xk+1 … xn`
            * `Y=y1 y2 … yk yk+1 … yn`
            * 随机选择第k位为交叉点，若采用对交叉点后面的基因进行交换的方法，但点交叉是将X中的xk+1到xn部分与Y中的yk+1到yn部分进行交叉，交叉后生成的两个新的个体是：
            * `X'= x1 x2 … xk yk+1 … yn`
            * `Y'= y1 y2 … yk xk+1 … xn`
        + 两点交叉
            * 两点交叉是指先在两个父代个体的编码串中随机设定两个交叉点，然后再按这两个交叉点进行部分基因交换，生成子代中的两个新的个体。
            * 假设两个父代的个体串分别是：
            * `X=x1 x2 … xi … xj … xn`
            * `Y=y1 y2 … yi … yj …,yn`
            * 随机设定第i、j位为两个交叉点（其中`i< j < n`），两点交叉是将X中的xi+1到xj部分与Y中的yi+1到yj部分进行交换，交叉后生成的两个新的个体是：
            * `X'= x1 x2 … xi yi+1 … yj xj+1 … xn`
            * `Y'= y1 y2 … yi xi+1 … xj yj+1 … yn`
        + 多点交叉
            * 多点交叉是指先随机生成多个交叉点，然后再按这些交叉点分段地进行部分基因交换，生成子代中的两个新的个体。
            * 假设交叉点个数为m，则可将个体串划分为m+1个分段，其划分方法是：
                - 当m为偶数时，对全部交叉点依次进行两两配对，构成m/2个交叉段。
                - 当m为奇数时，对前(m-1)个交叉点依次进行两两配对，构成(m-1)/2个交叉段，而第m个交叉点则按单点交叉方法构成一个交叉段。
        + 均匀交叉
            * 均匀交叉（Uniform Crossover）是先随机生成一个与父串具有相同长度，并被称为交叉模版（或交叉掩码）的二进制串，然后再利用该模版对两个父串进行交叉，即将模版中1对应的位进行交换，而0对应的位不交换，依此生成子代中的两个新的个体。事实上，这种方法对父串中的每一位都是以相同的概率随机进行交叉的。
    - 实值交叉
        + 实值交叉是在实数编码情况下所采用的交叉操作，主要包括离散交叉和算术交叉，下面主要讨论离散交叉（部分离散交叉和整体离散交叉） 。
        + 部分离散交叉是先在两个父代个体的编码向量中随机选择一部分分量，然后对这部分分量进行交换，生成子代中的两个新的个体。
        + 整体交叉则是对两个父代个体的编码向量中的所有分量，都以1/2的概率进行交换，从而生成子代中的两个新的个体。
        + 以部分离散交叉为例，假设两个父代个体的n维实向量分别是 `X=x1x2… xi…xk…xn`和`Y=y1y2…yi…yk…yn`，若随机选择对第k个分量以后的所有分量进行交换，则生成的两个新的个体向量是：
            * `X'= x1 x2 … xk yk+1 … yn`
            * `Y'= y1 y2 … yk xk+1 … xn`

(3)、变异操作
变异（Mutation）是指对选中个体的染色体中的某些基因进行变动，以形成新的个体。变异也是生物遗传和自然进化中的一种基本现象，它可增强种群的多样性。遗传算法中的变异操作增加了算法的局部随机搜索能力，从而可以维持种群的多样性。根据个体编码方式的不同，变异操作可分为二进制变异和实值变异两种类型。
* 二进制变异
    - 当个体的染色体采用二进制编码表示时，其变异操作应采用二进制变异方法。该变异方法是先随机地产生一个变异位，然后将该变异位置上的基因值由“0”变为“1”，或由“1”变为“0”，产生一个新的个体。
* 实值变异
    - 当个体的染色体采用实数编码表示时，其变异操作应采用实值变异方法。该方法是用另外一个在规定范围内的随机实数去替换原变异位置上的基因值，产生一个新的个体。
        + 基于位置的变异方法
            * 该方法是先随机地产生两个变异位置，然后将第二个变异位置上的基因移动到第一个变异位置的前面。
        + 基于次序的变异
            * 该方法是先随机地产生两个变异位置，然后交换这两个变异位置上的基因。

### 遗传算法的优势
1. 适应度函数不受连续、可微等条件的约束，适用范围很广。
2. 不容易陷入局部极值，能以很大的概率找到全局最优解。
3. 由于其固有的并行性，适合于大规模并行计算。
4. 不是盲目穷举，而是启发式搜索。


## 群智能系统
>由James Kenney（社会心理学博士）和[Russ Eberhart](http://www.engr.iupui.edu/~eberhart/)（电子工程学博士）于1995年提出粒子群算法（Particle Swarm Optimization, PSO）。

### 蚁群算法(Ant Colony Optimization,ACO)
通过遗留在来往路径上的信息素（Pheromone）的挥发性化学物质来进行通信和协调。
![](https://i.loli.net/2019/02/24/5c718197e8aa7.jpg)
* 蚂蚁在寻找食物的过程中往往是随机选择路径的，但它们能感知当前地面上的信息素浓度，并倾向于往信息素浓度高的方向行进。信息素由蚂蚁自身释放，是实现蚁群内间接通信的物质。
* 由于较短路径上蚂蚁的往返时间比较短，单位时间内经过该路径的蚂蚁多，所以信息素的积累速度比较长路径快。因此，当后续蚂蚁在路口时，就能感知先前蚂蚁留下的信息，并倾向于选择一条较短的路径前行。
* 这种正反馈机制使得越来越多的蚂蚁在巢穴与食物之间的最短路径上行进。由于其他路径上的信息素会随着时间蒸发，最终所有的蚂蚁都在最优路径上行进。

#### ACO基本要素

* 路径构建
伪随机比例选择规则
![](https://i.loli.net/2019/02/24/5c718197f149f.jpg)
    - 对于每只蚂蚁k，路径记忆向量Rk按照访问顺序记录了所有k已经经过的城市序号。
    - 设蚂蚁k当前所在城市为i，则其选择城市j作为下一个访问对象的概率如上式。Jk(i) 表示从城市i 可以直接到达的、且又不在蚂蚁访问过的城市序列Rk中的城市集合。
    - `η(i, j) `是一个启发式信息，通常由`η (i, j)=1/dij` 直接计算。
    - `τ (i, j)` 表示边`(i, j)`上的信息素量。
    - 长度越短、信息素浓度越大的路径被蚂蚁选择的概率越大。
    - α和β是两个预先设置的参数，用来控制启发式信息与信息素浓度作用的权重关系。
    - 当`α =0`时，算法演变成传统的随机贪心算法，最邻近城市被选中的概率最大。当`β =0`时，蚂蚁完全只根据信息素浓度确定路径，算法将快速收敛，这样构建出的最优路径与实际目标差异较大，算法性能较差。
* 信息素更新：
(1) 在算法初始化时，问题空间中所有的边上的信息素都被初始化为τ0。
(2) 算法迭代每一轮，问题空间中的所有路径上的信息素都会发生蒸发，我们为所有边上的信息素乘上一个小于1的常数( ρ: 信息素的蒸发率)。信息素蒸发是自然界本身固有的特征，在算法中能够帮助避免信息素的无限积累，使得算法可以快速丢弃之前构建过的较差的路径。
(3) 蚂蚁根据自己构建的路径长度在它们本轮经过的边上释放信息素。蚂蚁构建的路径越短、释放的信息素就越多。一条边被蚂蚁爬过的次数越多、它所获得的信息素也越多。
(4) 迭代 (2)，直至算法终止。
信息素的更新公式：
![](https://i.loli.net/2019/02/24/5c7182479d604.jpg)
    - `m`：蚂蚁个数；
    - `ρ`：信息素的蒸发率，规定`0<r≤1`。
    - `Δτ (i, j)`：第k只蚂蚁在它经过的边上释放的信息素量，它等于蚂蚁k本轮构建路径长度的倒数。
    - `Ck`：路径长度，它是Rk中所有边的长度和。

### 粒子群优化算法
* 源于对鸟群捕食行为的研究，是基于迭代的方法
* 简单易于实现，需要调整的参数相对较少
* 在函数优化、神经网络训练、工业系统优化和模糊系统控制等领域得到了广泛的应用。
    - 鸟群：假设一个区域，所有的鸟都不知道食物的位置，但是它们知道当前位置离食物还有多远。
    - PSO算法：每个解看作一只鸟，称为“粒子(particle)”，所有的粒子都有一个适应值，每个粒子都有一个速度决定它们的飞翔方向和距离，粒子们追随当前最优粒子在解空间中搜索。

#### 粒子群算法的特点
* PSO算法收敛速度快，特别是在算法的早期，但也存在着精度较低，易发散等缺点。
* 若加速系数、最大速度等参数太大，粒子群可能错过最优解，算法不收敛；
* 而在收敛的情况下，由于所有的粒子都向最优解的方向飞去，所以粒子趋向同一化（失去了多样性），使得后期收敛速度明显变慢，同时算法收敛到一定精度时，无法继续优化，所能达到的精度也不高。

### 其他计算智能方法
模拟退火、工免疫系统、粗集理论、EDA算法、文化进化计算、量子计算、DNA计算、智能Agent、……


## 多真体及自然语言理解 *
### Agent的定义和译法

>Agent的定义

* 定义1.社会中某个个体经过协商后可求得问题的解，这个个体就是agent.（明斯基，1986年）
* 定义2.是一种通过传感器知其环境，并通过执行器作用于该环境的实体，因此，可以把真体定义为一种从感知序列到实体动作的映射。（Russell and Norving,1995）
* 定义3.是一种具有智能的实体。

>Agent的译法

建议把agent译为“(艾)真体”的理由：
* Agent是一种通过传感器感知其环境，并通过执行器作用于该环境的实体。 这个“实体”也可叫做“真体”。因此，可以把真体定义为一种从感知序列到实体动作的映射。
* 译为“主体”可能是考虑到agent具有自主性。但交互性、协调性、社会性、适应性和分布性等不可能在译名上全部反映出来，因而是片面的。
* 译为“代理”是受到社会科学和管理科学的影响。也不能表示出agent的原义。
* 音译不失为一种可取方法。
* 有一定的物理意义。

### 真体的要素和特性

>真体的要素

真体必须利用知识修改其内部状态（心理状态），以适应环境变化和协作求解的需要。真体的行动受其心理状态驱动。人类心理状态的要素有认知（信念、知识、学习等）、情感（愿望、兴趣、爱好等）和意向（意图、目标、规划和承诺等）三种。着重研究信念（belief）、愿望（desire）和意图（intention）的关系及其形式化描述，力图建立真体的BDI（信念、愿望和意图）模型，已成为真体理论模型研究的主要方向。

>真体的特性

* 行为自主性：能够控制自身行为，其行为是主动的、自发的/有目标和意图的，并能根据目标和环境要求对短期行为做出规划。
* 作用交互性：能够与环境交互作用，能够感知其所处环境，并借助自己的行为结果，对环境做出适当反应。
* 环境协调性：真体存在于一定的环境中，感知环境的状态、事件和特征，并通过其动作和行为影响环境，与环境保持协调。环境和真体互相依存，互相作用。
* 面向目标性：真体能够表现出某种目标指导下的行为，为实现其内在目标而采取主动行为。
* 存在社会性：真体存在于由多个真体构成的社会环境中，与其它真体交换信息、交互作用和通讯。各真体通过社会承诺，进行社会推理，实现社会意向和目标。
* 工作协调性：各真体合作和协调工作，求解单个真体无法处理的问题，提高处理问题的能力。
* 运行持续性：真体的程序在起动后，能够在相当长的一段时间内维持运行状态，不随运算的停止而立即结束运行。
* 系统适应性：真体不仅能够感知环境，对环境做出反应，而且能够把新建立的真体集成到系统中而无需对原有的多真体系统进行重新设计，因而具有很强的适应性和可扩展性。
* 结构分布性：在物理上或逻辑上分布和异构的实体（或真体），如主动数据库、知识库、控制器和执行器等，在多真体系统中具有分布式结构，便于技术集成、资源共享、性能优化和系统整合。
* 功能智能性：真体强调理性作用，可作为描述机器智能、动物智能和人类智能的统一模型。

### 自然语言理解

>Natural Language Understanding 俗称人机对话。研究用电子计算机模拟人的语言交际过程，使计算机能理解和运用人类社会的自然语言如汉语、英语等，实现人机之间的自然语言通信，以代替人的部分脑力劳动，包括查询资料、解答问题、摘录文献、汇编资料以及一切有关自然语言信息的加工处理。
>这一领域的研究涉及自然语言，即人们日常使用的语言，包括中文、英文、俄文、日文、德文、法文等等，所以它与语言学的研究有着密切的联系，但又有重要的区别。
>自然语言处理并不是一般地研究自然语言，而在于研制能有效地实现自然语言通信的计算机系统，特别是其中的软件系统。

实现人机间自然语言通信意味着要使计算机既能理解自然语言文本的意义(即自然语言理解)，也能以自然语言文本来表达给定的意图、思想等(即自然语言生成)。
无论实现自然语言理解，还是自然语言生成，都远不如人们原来想象的那么简单，而是十分困难的。从目前的理论和技术现状看，通用的、高质量的自然语言处理系统，仍然是较长期的努力目标，但是针对一定应用，具有相当自然语言处理能力的实用系统已经出现，有些已商品化，甚至开始产业化。典型的例子有：各种数据库和专家系统的自然语言接口、各种机器翻译系统、全文信息检索系统、自动文摘系统等。

自然语言处理，即实现人机间自然语言通信，或实现 **自然语言理解**和 **自然语言生成**是十分困难的。
造成困难的 **根本原因**是自然语言文本和对话的各个层次上广泛存在的各种各样的歧义性或多义性（ambiguity）。
一般情况下，它们中的大多数都是可以根据相应的语境和场景的规定而得到解决的。也就是说，从总体上说，并不存在歧义。这也就是我们平时并不感到自然语言歧义，和能用自然语言进行正确交流的原因。但是一方面，我们也看到，为了消解歧义，是需要极其大量的知识和进行推理的。如何将这些知识较完整地加以收集和整理出来；又如何找到合适的形式，将它们存入计算机系统中去；以及如何有效地利用它们来消除歧义，都是工作量极大且十分困难的工作。这不是少数人短时期内可以完成的，还有待长期的、系统的工作。

### 存在问题
* 一方面，迄今为止的语法都限于分析一个孤立的句子，上下文关系和谈话环境对本句的约束和影响还缺乏系统的研究，因此分析歧义、词语省略、代词所指、同一句话在不同场合或由不同的人说出来所具有的不同含义等问题，尚无明确规律可循。
* 另一方面，人理解一个句子不是单凭语法，还运用了大量的有关知识，包括生活知识和专门知识，这些知识无法全部贮存在计算机里。因此一个书面理解系统只能建立在有限的词汇、句型和特定的主题范围内。

### 如何看待语言理解
* 从微观上讲，语言理解是指从自然语言到机器(计算机系统)内部之间的一种映射。
* 从宏观上看，语言理解是指机器能够执行人类所期望的某些语言功能。这些功能包括：
    - 回答有关提问；
    - 提取材料摘要；
    - 不同词语叙述；
    - 不同语言翻译。

### 自然语言理解的研究领域和方向
文字识别、语音识别、机器翻译、自动文摘、句法分析、文本分类、信息检索、信息获取、信息过滤、自然语言生成、中文自动分词、语音合成、问答系统

用自然语言与计算机进行通信，这是人们长期以来所追求的。因为它既有明显的实际意义，同时也有重要的理论意义：人们可以用自己最习惯的语言来使用计算机，而无需再花大量的时间和精力去学习不很自然和习惯的各种计算机语言；人们也可通过它进一步了解人类的语言能力和智能的机制。