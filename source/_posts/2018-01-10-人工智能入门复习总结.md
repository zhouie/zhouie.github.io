---
title: 人工智能入门复习总结
categories:
  - XTU
tags:
  - XTU
  - 专业课
  - AI
abbrlink: 201801101
date: 2018-01-10 13:03:51
---


## 绪论

### 人工智能的定义与发展

#### 定义

1. *一般解释*：人工智能就是用 **人工**的方法在 **机器（计算机）**上实现的智能，或称 **机器智能**；
2. *人工智能(学科)*：从学科的角度来说，人工智能是一门研究如何 **构造智能机器或智能系统**，使之能模拟、延伸、扩展人类智能的学科；
3. *人工智能(能力)*：从智能能力的角度来说，人工智能是智能机器所执行的通常 **与人类智能有关的智能行为**，如判断、推理、证明、识别、感知、理解、通信、设计、思考、规划、学习和问题求解等思维活动。 

<**补充**> 2018年1月发布的[人工智能标准化白皮书](https://download.csdn.net/download/jave_f/10464580)上关于“人工智能的概念”有如下一段详尽描述（仅供参考）：

>2.1.2 人工智能的概念
>
>人工智能作为一门前沿交叉学科，其定义一直存有不同的观点：**《人工智能——一种现代方法》**中将已有的一些人工智能定义分为四类：像人一样思考的系统、像人一样行动的系统、理性地思考的系统、理性地行动的系统。**维基百科**上定义“人工智能就是机器展现出的智能”，即只要是某种机器，具有某种或某些“智能”的特征或表现，都应该算作“人工智能”。**大英百科全书**则限定人工智能是数字计算机或者数字计算机控制的机器人在执行智能生物体才有的一些任务上的能力。**百度百科**定义人工智能是“研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学”，将其视为计算机科学的一个分支，指出其研究包括机器人、语言识别、图像识别、自然语言处理和专家系统等。
>
>本白皮书认为，**人工智能是利用数字计算机或者数字计算机控制的机器模拟、延伸和扩展人的智能，感知环境、获取知识并使用知识获得最佳结果的理论、方法、技术及应用系统。**
>
>人工智能的定义对人工智能学科的基本思想和内容作出了解释，即围绕智能活动而构造的人工系统。人工智能是知识的工程，是机器模仿人类利用知识完成一定行为的过程。根据人工智能是否能真正实现推理、思考和解决问题，可以将人工智能分为弱人工智能和强人工智能。
>
>**弱人工智能**是指不能真正实现推理和解决问题的智能机器，这些机器表面看像是智能的，但是并不真正拥有智能，也不会有自主意识。迄今为止的人工智能系统都还是实现特定功能的专用智能，而不是像人类智能那样能够不断适应复杂的新环境并不断涌现出新的功能，因此都还是弱人工智能。目前的主流研究仍然集中于弱人工智能，并取得了显著进步，如语音识别、图像处理和物体分割、机器翻译等方面取得了重大突破，甚至可以接近或超越人类水平。
>
>**强人工智能**是指真正能思维的智能机器，并且认为这样的机器是有知觉的和自我意识的，这类机器可分为类人（机器的思考和推理类似人的思维）与非类人（机器产生了和人完全不一样的知觉和意识，使用和人完全不一样的推理方式）两大类。从一般意义来说，达到人类水平的、能够自适应地应对外界环境挑战的、具有自我意识的人工智能称为“通用人工智能”、“强人工智能”或“类人智能”。强人工智能不仅在哲学上存在巨大争论（涉及到思维与意识等根本问题的讨论），在技术上的研究也具有极大的挑战性。强人工智能当前鲜有进展，美国私营部门的专家及国家科技委员会比较支持的观点是，至少在未来几十年内难以实现。
>
>靠符号主义、连接主义、行为主义和统计主义这四个流派的经典路线就能设计制造出强人工智能吗？其中一个主流看法是：即使有更高性能的计算平台和更大规模的大数据助力，也还只是量变，不是质变，人类对自身智能的认识还处在初级阶段，在人类真正理解智能机理之前，不可能制造出强人工智能。理解大脑产生智能的机理是脑科学的终极性问题，绝大多数脑科学专家都认为这是一个数百年乃至数千年甚至永远都解决不了的问题。
>
>通向强人工智能还有一条“新”路线，这里称为“仿真主义”。这条新路线通过制造先进的大脑探测工具从结构上解析大脑，再利用工程技术手段构造出模仿大脑神经网络基元及结构的仿脑装置，最后通过环境刺激和交互训练仿真大脑实现类人智能，简言之，“先结构，后功能”。虽然这项工程也十分困难，但都是有可能在数十年内解决的工程技术问题，而不像“理解大脑”这个科学问题那样遥不可及。
>
>仿真主义可以说是符号主义、连接主义、行为主义和统计主义之后的第五个流派，和前四个流派有着千丝万缕的联系，也是前四个流派通向强人工智能的关键一环。经典计算机是数理逻辑的开关电路实现，采用冯•诺依曼体系结构，可以作为逻辑推理等专用智能的实现载体。但要靠经典计算机不可能实现强人工智能。要按仿真主义的路线“仿脑”，就必须设计制造全新的软硬件系统，这就是“类脑计算机”，或者更准确地称为“仿脑机”。“仿脑机”是“仿真工程”的标志性成果，也是“仿脑工程”通向强人工智能之路的重要里程碑。

#### 起源与发展

人工智能始于20世纪50年代，50多年来，人工智能走过了一条起伏和曲折的发展道路。回顾历史，可以按照不同时期的主要特征，将其产生与发展过程分为5个阶段。

1、孕育期（1956年前）

2、形成期（1956-1970年）

1956年夏，麦卡锡 (J.McCarthy，数学家、计算机专家)、明斯基(M.L.Minsky，哈佛大学数学家、神经学家)、洛切斯特(N.Lochester，IBM公司信息中心负责人)、香农(C.E.Shannon，贝尔实验室信息部数学家和信息学家)
邀请莫尔(T.more)、塞缪尔(A.L.Samuel) 、塞尔夫里奇(O.Selfridge)、索罗蒙夫(R.Solomonff)、纽厄尔(A.Newell)、西蒙(H.A.Simon)在 **美国达特莫斯(Dartmouth)大学**举办了长达历时两个月的研讨会。会上，麦卡锡正式使用“人工智能AI”这一术语。这是人类历史上首次第一次人工智能研讨会，**标志着人工智能学科的诞生**。

3、暗淡期（1966-1974年）

**失败的预言**给人工智能的声誉造成重大伤害
60年代初，西蒙预言：10年内计算机将成为世界冠军、将证明一个未发现的数学定理、将能谱写出具有优秀作曲家水平的乐曲、大多数心理学理论将在计算机上形成。

**挫折和困境**
* 在博弈方面：塞缪尔的下棋程序在与世界冠军对弈时，5局败了4局。
* 在定理证明方面：发现鲁宾逊归结法的能力有限。当用归结原理证明两个连续函数之和还是连续函数时，推了10万步也没证出结果。
* 在问题求解方面：对于不良结构，会产生 **组合爆炸**问题。
* 在机器翻译方面：发现并不那么简单，甚至会闹出笑话。例如，把“心有余而力不足”的英语句子翻译成俄语，再翻译回来时竟变成了“酒是好的，肉变质了”
* 在神经生理学方面：研究发现人脑有1011-12以上的神经元，在现有技术条件下用机器从结构上模拟人脑是根本不可能的。
* 在其它方面：人工智能也遇到了不少问题。在英国，剑桥大学的詹姆教授指责“人工智能研究不是骗局，也是庸人自扰” 。从此，形势急转直下，在全世界范围内人工智能研究陷入困境、落入低谷。 

**Minsky的批评**
1969年 M. Minsky 和 S. Papert 在《感知机》一书中指出了感知机无法解决异或（XOR）问题的缺陷，并表示出对这方面研究的悲观态度，使得神经网络的研究从兴起期进入了停滞期。 
该批评对人工智能的发展造成了重要的影响
* 在以后的二十年，感知机的研究方向被忽视
* 基于符号的知识表示成为主流
* 基于逻辑的推理成为主要研究方向

**当时的人工智能存在三个方面的局限性**
* 知识局限性：早期开发的人工智能程序中包含了太少的主题知识，甚至没有知识，而且只采用简单的句法处理。
* 解法局限性：求解方法和步骤的局限性使得设计的人工智能程序在实际上无法求得问题的解答，或者只能得到简单问题的解答，而这种简单问题并不需要人工智能的参与。
* 结构局限性：用于产生智能行为的人工智能系统或程序在一些基本结构上严重局限，如没有考虑不良结构，无法处理组合爆炸问题，因而只能用于解决比较简单的问题，影响到人工智能系统的推广应用。

4、知识应用期（ 1970-1988年）

5、集成发展期（1986年至今）

人工智能具体的发展历程图示如下：
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/AI_history.jpg)

这两年人工智能得到了突飞猛进的发展，实现这种发展的基本条件有三个：
* **大数据的积累**
* **计算能力的提升**
* **理论算法的革新**

### 各种认知观

#### 目前人工智能主要有以下三个学派：

* **符号主义**（Symbolicism）: 基于物理符号系统假设和有限合理性原理（逻辑）

符号主义观点认为：智能的基础是知识，**其核心是知识表示和知识推理**；知识可用符号表示，也可用符号进行推理，因而可以建立基于知识的人类智能和机器智能的统一的理论体系。

* **连接主义****（Connectionism）: 基于神经网络及其间的连接机制与学习算法（仿生）

连接主义观点认为：**思维的基元是神经元**，而不是符号；思维过程是神经元的联结活动过程，而不是符号运算过程；反对符号主义关于物理符号系统的假设。

* **行为主义**（Actionism）: 基于控制论及感知—动作型控制系统（进化）

行为主义观点认为：**智能取决于感知和行动**，提出了智能行为的“感知—动作”模型；**智能不需要知识、不需要表示、不需要推理**；人工智能可以像人类智能那样逐步进化。

此外，还有一种由[钟义信](https://baike.baidu.com/item/%E9%92%9F%E4%B9%89%E4%BF%A1/7371623?fr=aladdin)院士提出的一种认知学派：

* **机制主义**（mechanism）：结构（连接）主义、功能（符号）主义、行为主义的和谐统一。

#### 几种学派各自不足之处：

* **符号主义的不足**(功能模拟法/认知学观点)
    - 在用符号表示知识的概念时，有效性很大程度上取决于符号表示的正确性和准确性
    - 将知识概念转换成符号时，可能丢失一些重要信息
    - 难于对含噪信息、不确定性信息和不完全性信息进行处理

* **连接主义的不足**(结构模拟法/生物学观点)
    - 由于大脑的生理结构和工作机理还远未搞清楚，因而现在只能对人脑的局部进行模拟或进行近似模拟
    - 不适合模拟人的逻辑思维过程
    - 受大规模人工神经网络制造的制约
    - 尚不能满足人脑完全模拟的要求

* **行为主义的不足**
    - 难以获得高级智能控制行为

### 研究目标与内容

#### 研究目标

远期目标：构造出可以实现人类思维活动和智力功能的智能系统。
近期目标：使现有的计算机更聪明更有用，使它不仅能够进行一般的数值计算和非数值信息的处理，而且能够运用知识去处理问题，能够模拟人类的智能行为。

#### 研究的基本内容

1、认知建模
认知：可一般地认为是和情感、动机、意志相对应的理智或认识过程，或者是为了一定的目的，在一定的心理结构中进行的信息加工过程。

2、知识表示：基础

3、知识推理：实现问题求解

4、知识应用：目的

> 知识表示、知识推理、知识应用是传统人工智能的三大核心研究内容。

5、机器感知：就是要让计算机具有类似于人的感知能力，如视觉、听觉、触觉、嗅觉、味觉……，是机器获取外部信息的基本途径
* 相当于智能系统的输入部分
* 机器视觉（或叫计算机视觉）：就是给计算机配上能看的视觉器官，如摄像机等，使它可以识别并理解文字、图像、景物等
* 机器听觉（或叫计算机听觉）：就是给计算配上能听的听觉器官，如话筒等，使计算机能够识别并理解语言、声音等。
* 模式识别：对客体的识别与分类
* 自然语言理解：实现人机对话
* 机器翻译

6、机器思维：
机器思维是让计算机能够对感知到的外界信息和自己产生的内部信息进行思维性加工，包括逻辑思维、形象思维和灵感思维，涉及信息的表示，组织，积累，管理，搜索，推理等过程。

7、机器学习：
* 让计算机能够像人那样自动地获取新知识，并在实践中不断地完善自我和增强能力。
* 是机器获取智能的途径
* 学习是一个有特定目的的知识获取过程，学习的本质是对信息的理解与应用

8、机器行为：
* 让计算机能够具有像人那样地行动和表达能力，如走、跑、拿、说、唱、写画等。
* 相当于智能系统的输出部分

9、智能系统构建
* 无论是人工智能的近期目标还是远期目标，都需要建立智能系统或构造智能机器
* 需要开展对系统模型、构造技术、构造工具及语言环境等研究

### 应用领域

问题求解、机器学习、自然语言理解、专家系统、模式识别、计算机视觉、机器人学、博弈、计算智能、人工生命、自动定理证明、自动程序设计、智能控制、智能检索、智能调度与指挥、智能决策支持系统、人工神经网络、数据挖掘与知识发现......

### 课后习题

1-1 什么是人工智能？是从科学与能力两方面加以说明。
1-3 在人工智能的发展过程中，有哪些思想和思潮起到了重要作用？
1-5 人工智能有哪些学派？他们的认知观是什么？现在这些学派的关系如何？
1-9 人工智能的基本研究方法有哪些类？
1-10 人工智能的主要研究和应用领域是什么？其中，哪些是新的研究热点？

## 知识表示与推理

### 知识表示方法

>知识的一般概念

知识是人们在改造客观世界的实践中积累起来的 **认识**和 **经验**。
其中，**认识**与 **经验**可以这样定义：
* 认识：包括对事物现象、本质、属性、状态、联系等的认识
* 经验：包括解决问题的微观方法和宏观方法
    - 微观方法：如步骤、操作、规则、过程、技巧等
    - 宏观方法：如战略、战术、计谋、策略等

>人工智能系统中的知识

一个智能程序高水平的运行需要有关的 **事实知识**、 **规则知识**、 **控制知识**和 **元知识**。

* 事实知识 ：是有关问题环境的一些事物的知识，常以“…是…”的形式出现。
    - 如事物的分类、属性、事物间关系、科学事实、客观事实等。
    - 事实是静态的为人们共享的可公开获得的公认的知识，在知识库中属低层的知识，如：雪是白色的、鸟有翅膀、张三李四是好朋友、这辆车是张三的……
* 规则知识 ：是有关问题中与事物的行动、动作相联系的因果关系知识，是动态的，常以“如果…那么…” 形式出现。
* 控制知识 ：是有关问题的求解步骤、技巧的知识，告诉人们怎么做一件事，也包括当有多个动作同时被激活时应选哪一个动作来执行的知识。控制知识常与程序结合在一起出现，如一个问题求解的算法可以看做是一种知识表示。
* 元知识 ：是有关知识的知识，是知识库中的高层知识。包括怎样使用规则、解释规则、校验规则、解释程序结构等知识。

元知识与控制知识是有重迭的，对一个大的程序来说，以元知识或说元规则形式体现控制知识更为方便，因为元知识存于知识库中，而控制知识常与程序结合在一起出现，从而不容易修改。 

>知识表示

研究用机器表示知识的可行性、有效性的一般方法，是一种数据结构与控制结构的统一体，既考虑知识的存储又考虑知识的使用。

知识表示的要求：
* 表示能力：能否正确、有效地表示问题。包括：表范围的广泛性、领域知识表示的高效性、对非确定性知识表示的支持程度；
* 可利用性：可利用这些知识进行有效推理。包括：对推理的适应性，对高效算法的支持程度；
* 可实现性：要便于计算机直接对其进行处理；
* 可组织性：可以按某种方式把知识组织成某种知识结构；
* 可维护性：便于对知识的增、删、改等操作；
* 自然性：符合人们的日常习惯；
* 可理解性：知识应易读、易懂、易获取等。

#### 状态空间法

状态空间法是一种 **基于解答空间的问题表示和求解方法**，它是以“**状态**（state）”和“**算符**（operator）”为基础的，它是人工智能中最基本的 **形式化方法**。
由于状态空间法需要扩展过多的节点，容易出现“**组合爆炸**”，因而 **只适用于表示比较简单的问题**。

>状态空间法的三要素： 

1. **状态**（state）：描述某类不同事物间的差别而引入的一组最少变量 `q0，q1，…，qn`的有序集合，是表示问题解法中每一步问题状况的数据结构。有序集合中每个元素qi（i= 0,1,...,n）为集合的分量，称为状态变量。给定每个分量的一组值就得到一个具体的状态。
2. **算符**（operator）：使问题从一种状态变化为另一种状态的手段称为操作符或算符。
3. **问题的状态空间****：即解答空间，也就是一个表示该问题全部可能状态及其关系的图。它是以状态和算符为基础来表示和求解问题的。它包含三种说明的集合，即S：所有可能的问题初始状态集合、F：操作符集合、G：目标状态集合。可将状态空间记为三元状态`（S，F，G）`。

---

【例子】 
**猴子和香蕉问题**：在一个房间内有一只猴子、一个箱子和一束香蕉。香蕉挂在天花板下方，但猴子的高度不足以碰到它。那么这只猴子怎样才能摘到香蕉呢?
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E7%8C%B4%E5%AD%90%E6%91%98%E9%A6%99%E8%95%89.jpg)

**解题过程**
用一个四元表列`(W，x，Y，z)`来表示这个问题状态空间 
其中W：猴子的水平位置；x：当猴子在箱子顶上时取1；否则取0；Y：箱子的水平位置；z：当猴子摘到香蕉时取1；否则取0。 
则可见初始状态为`(a,0,b,0)`，目标状态为`(c,1,c,1)` 

这个问题的算符如下： 
`goto(U)`表示猴子走到水平位置U；`pushbox(V)`表示猴子把箱子推到水平位置V；`climbbox`表示猴子爬上箱顶；`grasp`表示猴子摘到香蕉。

由初始状态变换为目标状态的操作序列为：
    Step1: `goto(b) `
    Step2: `pushbox(c) `
    Step3: `climbbox `
    Step4: `grasp `
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E6%B3%95.jpg)

---

#### 问题归约法

> 问题规约（Problem Reduction）：

* 另外一种 **基于状态空间**的问题描述与求解方法；
* 已知问题的描述，通过一系列 **变换** 把此问题变为一个 **子问题集合**；
* 这些子问题的解可以直接得到（**本原问题**），从而解决了初始问题。

> 问题归约的组成部分：

* 一个初始问题描述；
* 一套把问题变换为子问题的 **操作符**；
* 一套本原问题描述。(本原问题:不能再分解或变换且直接可解的子问题)。

> 问题归约的 **实质**：

* 从目标（要解决的问题）出发 **逆向推理**，建立子问题以及子问题的子问题，直到 **最后把初始问题归约为一个本原问题集合**。

> 问题归约法举例：

---

【例子】
**汉诺塔问题**(Hanoi):规定每次移动一个盘子、且总个过程中大盘在下小盘在上、目标是将盘子从柱子1移到柱子3。
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/Hanoi.jpg)

**解题过程**

原始问题可以归约为下列3个子问题：
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E9%97%AE%E9%A2%98%E8%A7%84%E7%BA%A6%E6%B3%95.jpg)

规约过程：
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E8%A7%84%E7%BA%A6%E8%BF%87%E7%A8%8B.jpg)

归约图示：
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E8%A7%84%E7%BA%A6%E5%9B%BE.jpg)

---

>与或图表示

用一个类似于图的结构来表示,把问题归约为后继问题的替换集合。
* 与图：把一个复杂问题分解为若干个较为简单的子问题，形成“与”树。
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E4%B8%8E%E5%9B%BE.jpg)

* 或图：把原问题变换为若干个较为容易求解的新问题，形成“或”树。
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%88%96%E5%9B%BE.jpg)

#### 谓词逻辑法
谓词逻辑法采用谓词合式公式和一阶谓词演算将要解决的问题变成一个有待证明的问题，然后利用消解定理和消解反演来证明一个新语句是从已知的正确语句中导出的，从而证明这个新语句也是正确的。
谓词逻辑是一种 **形式语言**，能够将数学中的逻辑论证符号化，谓词逻辑经常与其他表示方法混合使用，**可以表示比较复杂的问题**。

##### 谓词演算

>语法和语义

* 基本符号：谓词符号、变量符号、函数符号、常量符号、括号和逗号
* 原子公式由若干谓词符号和项组成

>连词和量词

* 连词
合取、析取、蕴涵、非、双条件

* 量词
全称量词、存在量词

>谓词公式

* 原子谓词公式
由谓词符号和若干项组成的谓词演算

* 分子谓词公式
可以用 **连词**把原子谓词公式组成复合谓词公式，并把它叫做分子谓词公式
通常把合式公式叫做谓词公式。在谓词演算中合式公式的递归定义如下：
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%90%88%E5%BC%8F%E5%85%AC%E5%BC%8F.jpg)

>合式公式的性质

![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%80%A7%E8%B4%A8.jpg)

##### 置换与合一

>置换

置换是用变元、常量、函数来替换变元，使该变元不在公式中出现，形如`{t1/x1, t2/x2,...，tn/xn}`的有限集合，其中：
* `t1，t2，...，tn`是项；
* `x1，x2，...，xn`是互不相同的变元；
* `ti/xi`表示用ti项替换变元`xi`，不允许`ti`和`xi`相同，也不允许变元`xi`循环地出现在另一个tj中。

推理规则：用合式公式的集合产生新的合式公式
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%8E%A8%E7%90%86%E8%A7%84%E5%88%99.jpg)

置换是 **可结合的**；
用`s1s2`表示两个置换s1和s2的合成，L表示一个表达式，则有`(Ls1)s2 = L(s1s2)`以及`(s1s2)s3 = s1(s2s3)`，即用s1和s2相继作用于表达式L是与用`s1s2`作用于L一样的。
一般说来，置换是 **不可交换的**，即`s1s2 ≠ s2s1`。

>合一

寻找项对变量的置换，以使两表达式一致，叫做合一。
如果一个置换s作用于表达式集合`{Ei}`的每个元素，则用`{Ei}s`来表示置换的集。称表达式{Ei}是可合一的，如果存在一个置换s使得：`E1s = E2s =  E3s =……`，那么，称此s为`{Ei}`的合一者，因为s的作用是使集合`{Ei}`成为单一形式。
例如：设有公式集`E={ P( x, y, f(y)),  P( a, g(x), z) }`，则`s={a/x, g(a)/y, f(g(a))/z}`是它的一个合一。


#### 语义网路法

语义网络是通过概念及其语义关系来表达知识一种网络图，是一种 **结构化表示方法**。
从图论的观点看，语义网络是一个“带标识的有向图”，它由 **节点**和 **弧线或链线**组成。**节点代表实体、概念、情况等**，**弧线代表节点间的关系**，必须带标识。
语义网络的解答是一个经过推理和匹配而得到的具有明确结果的新的语义网路，扩展后可以表示更复杂的问题。

语义网络中最基本的语义单元称为语义基元，可用三元组表示为：(结点1，弧，结点2)。

> 二元语义网络的表示

例如：用语义网络表示：李新的汽车的款式是“捷达”、银灰色；王红的汽车的款式是“凯越”、红色；李新和王红的汽车均属于具体概念,可增加“汽车” 这个抽象概念。
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E8%AF%AD%E4%B9%89%E7%BD%91%E7%BB%9C.jpg)

> 多元语义网络的表示

* 增加情况和动作节点；
* 增加事件节点；
* 连接词和量词的表示；
* ......


#### 其他方法

* 框架表示法
这是一种 **结构化方法**；
框架理论是明斯基于1975年作为理解视觉、自然语言对话及其它复杂行为的一种基础提出来的；
框架理论认为，人们对现实世界中各种事物的认识都是以一种类似于框架的结构存储在记忆中的。当遇到一个新事物时，就从记忆中找出一个合适的框架，并根据新的情况对其细节加以修改、补充，从而形成对这个新事物的认识。

框架网络：
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A1%86%E6%9E%B6%E7%BD%91%E7%BB%9C.jpg)

框架结构：
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84.jpg)
* 每个框架都有框架名，代表某一类对象
* 一个框架由若干个槽（项目）组成，用于表示对象的某个方面的属性
* 有时一个槽（属性）还要从不同的侧面来描述，每个侧面可具有一个或多个值。
注意：框架中的槽与侧面可任意定义，也可以是另一框架，形成框架网络系统。

* 剧本表示法(ppt-6)
* 过程表示法(ppt-6)
* ......

### 确定性推理

#### 推理的基本概念

>推理方法及其分类

1. 按推理的逻辑基础分：演绎推理，归纳推理，类比归纳推理
2. 按推理过程所用知识的确定性分：确定性推理、 不确定性推理
3. 按推理过程推出的结论是否单调增加分：单调推理、非单调推理
4. 按推理过程是否利用问题的启发性知识分：启发式推理、非启发式推理

>推理的控制策略及其分类

推理的控制策略是指如何使用领域知识使推理过程尽快达到目标的策略。

* 推理策略
    - **推理方向控制策略**可分为
        + 正向推理
        + 逆向推理
        + 混合推理
        + 双向推理
    - **求解策略**：是指仅求一个解，还是求所有解或最优解等。
    - **限制策略**：是指对推理的深度、宽度、时间、空间等进行的限制。
    - **冲突消解策略**：是指当推理过程有多条知识可用时，如何从这多条可用知识中选出一条最佳知识用于推理的策略。
* 搜索策略（下面会详述）

#### 搜索策略

* 按是否使用启发式信息：
    - 盲目搜索：按预定的控制策略进行搜索，在搜索过程中获得的中间信息并不改变控制策略。 
    - 启发式搜索：在搜索中加入了与问题有关的启发性信息，用于指导搜索朝着最有希望的方向前进，加速问题的求解过程并找到最优解。 
* 按问题的表示方式：
    - 状态空间搜索：用指用状态空间法来表示问题所进行的搜索 
    - 与或树搜索：用指用问题归约法来表示问题所进行的搜索 

##### 状态空间的搜索策略

* 状态空间的盲目搜索
    - 广度优先搜索
    - 深度优先搜索
    - 代价树搜索
* 状态空间的启发式搜索
    - 启发性信息和估价函数
    - A算法和A*算法
* 基本思想
    - 先把问题的初始状态作为当前扩展节点对其进行扩展，生成一组子节点。
    - 然后检查问题的目标状态是否出现在这些子节点中。若出现，则搜索成功，找到了问题的解；若没出现，则再 **按照某种搜索策略**从已生成的子节点中选择一个节点作为当前扩展节点。
    - 重复上述过程，直到目标状态出现在子节点中或者没有可供操作的节点为止。
    - 所谓对一个节点进行“扩展”是指对该节点用某个可用操作进行作用，生成该节点的一组子节点。 
* 数据结构和符号约定
    - **OPEN表**：未扩展节点表，用于存放刚生成节点
    - **CLOSED表**：已扩展节点表，用于存放已经扩展或将要扩展的节点
    - S：用表示问题的初始状态
    - G：表示搜索过程所得到的搜索图
    - M：表示当前扩展节点新生成的且不为自己先辈的子节点集

*各种搜索策略的主要区别在于对OPEN表中节点的排列顺序不同。*例如，广度优先搜索把先生成的子节点排在前面，而深度优先搜索则把后生成的子节点排在前面。

>广度优先搜索算法流程：

1. 把初始节点S放入OPEN表中；
2. 如果OPEN表为空，则问题无解，失败退出；
3. 把OPEN表的第一个节点取出放入CLOSED表，并记该节点为n；
4. 考察节点n是否为目标节点。若是，则得到问题的解，成功退出；
5. 若节点n不可扩展，则转第(2)步；
6. 扩展节点n，将其子节点放入OPEN表的 **尾部**，并为每一个子节点设置指向父节点的指针，然后转第(2)步。

以八数码问题为例，得到下面这个广度优先搜索树：
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88.jpg)

在上述广度优先算法中需要注意两个问题：
* 对于任意一个可扩展的节点，总是按照固定的操作符的顺序对其进行扩展（空格左移、上移、右移、下移）。
* 在对任一节点进行扩展的时候，如果所得的某个子节点（状态）前面已经出现过，则立即将其放弃，不再重复画出（不送入OPEN表）。
因此，广度优先搜索的本质是，以初始节点为根节点，在状态空间图中按照广度优先的原则，生成一棵搜索树。

广度优先搜索的优缺点：
* 优点
    - 只要问题有解，用广度优先搜索总可以得到解，而且得到的是路径最短的解。
* 缺点
    - 广度优先搜索盲目性较大，当目标节点距初始节点较远时将会产生许多无用节点，搜索效率低。

>深度优先搜索算法流程： 

1. 把初始节点S放入OPEN表中；
2. 如果OPEN表为空，则问题无解 ，失败退出；
3. 把OPEN表的第一个节点取出放入CLOSED表，并记该节点为n；
4. 考察节点n是否为目标节点。若是，则得到问题的解，成功退出；
5. 若节点n不可扩展，则转第(2)步； 
6. 扩展节点n，将其子节点放入OPEN表的 **首部**，并为每一个子节点设置 指向父节点的指针，然后转第(2)步。

在深度优先搜索中，搜索一旦进入某个分支，就将沿着该分支一直向下搜索。如果目标节点恰好在此分支上，则可较快地得到解。但是，如果目标节点不在此分支上，而该分支又是一个无穷分支，则就不可能得到解。所以深度优先搜索是不完备的，即使问题有解，它也不一定能求得解。
因此，为了防止搜索过程沿着无益的路径扩展下去，往往给出一个节点扩展的最大深度，即 **深度界限**。当搜索深度达到了深度界限而仍未出现目标节点时，就换一个分支进行搜索。

有界深度优先搜索的特点：

* 从某种意义上讲，有界深度优先搜索具有一定的启发性；
* 如果问题有解，且其路径长度≤dm，则上述搜索过程一定能求得解。
* 但是若解的路径长度> dm,则上述搜索过程就得不到解。。
* 这说明在有界深度优先搜索中，深度界限的选择是很重要的，但是要恰当地给出dm的值是比较困难的。
* 即使能求出解，它也不一定是最优解。

>代价树搜索

考虑边的代价的搜索方法，代价树搜索的目的是为了找到一条代价最小的解路径。代价树搜索方法包括：
* 代价树的广度优先搜索
* 代价树的深度优先搜索

>启发式信息与代价函数

采用问题自身的特性信息，以指导搜索朝着最有希望的方向前进。
启发性信息是指那种与具体问题求解过程有关的，并可指导搜索过程朝着最有希望方向前进的控制信息。启发信息的启发能力越强，扩展的无用结点越少。

启发性信息的种类
* 有效地帮助确定扩展节点的信息；
* 有效的帮助决定哪些后继节点应被生成的信息；
* 能决定在扩展一个节点时哪些节点应从搜索树上删除的信息。

估价函数的一般形式为：`f(x) = g(x)+h(x)`，其中`g(x)`表示从初始节点S0到节点x的代价；`h(x)`是从节点x到目标节点Sg的最优路径的代价的估计，它体现了问题的启发性信息，`h(x)`称为启发函数。

>A算法与A*算法

A算法：在图搜索算法中，如果能在搜索的每一步都利用估价函数`f(n)=g(n)+h(n)`对OPEN表中的节点进行排序，则该搜索算法为A算法。

A算法的类型
可根据搜索过程中选择扩展节点的范围，将启发式搜索算法分为：
* 全局择优搜索算法： 从OPEN表的所有节点中选择一个估价函数值最小的一个进行扩展。
* 局部择优搜索算法：仅从刚生成的子节点中选择一个估价函数值最小的一个进行扩展。

A*算法是对A算法的估价函数`f(n)=g(n)+h(n)`加上某些限制后得到的一种启发式搜索算法。

假设`f*(n)`是从初始节点出发经过节点n达到目标节点的最小代价，估价函数`f(n)`是对`f*(n)`的 **估计值**。且`f*(n)=g*(n)+h*(n)`，`g*(n)`是从初始节点S0到节点n的最小代价。`h*(n)`是从节点n到目标节点的最小代价，**若有多个目标节点，则为其中最小的一个**。

A*算法对A算法（全局择优的启发式搜索算法）中的`g(n)`和`h(n)`分别提出如下限制：

* 第一，`g(n)`是对最小代价`g*(n)`的估计，且`g(n)>0`；
* 第二，`h(n)`是最小代价`h*(n)`的下界，即对任意节点n均有`h(n)≤h*(n)`。

即：满足上述两条限制的A算法称为A*算法。


##### 与/或树的搜索策略(ppt-9~10)

1、 与/或树的一般搜索过程

```
(1) 把原始问题作为初始节点S0，并把它作为当前节点； 
(2) 应用分解或等价变换操作对当前节点进行扩展； 
(3) 为每个子节点设置指向父节点的指针； 
(4) 选择合适的子节点作为当前节点，反复执行第(2)步和第(3)步，在此期间需要多次调用可解标记过程或不可解标记过程，直到初始节点被标记为可解节点或不可解节点为止。
```

2、 与/或树的广度优先搜索

```
(1)把初始节点S0放入OPEN表中； 
(2)把OPEN表的第一个节点取出放入CLOSED表，并记该节点为n； 
(3)如果节点n可扩展，则做下列工作：
    ① 扩展节点n，将其子节点放入OPEN表的尾部，并为每一个子节点设置指向父节点的指针；
    ② 考察这些子节点中有否终止节点。若有，则标记这些终止节点为可解节点，并用可解标记过程对其父节点及先辈节点中的可解解节点进行标记。如果初始解节点S0能够被标记为可解节点，就得到了解树，搜索成功，退出搜索过程；如果不能确定S0为可解节点，则从OPEN表中删去具有可解先辈的节点。
    ③ 转第(2)步。
(4) 如果节点n不可扩展，则作下列工作： 
    ① 标记节点n为不可解节点；
    ② 应用不可解标记过程对节点n的先辈中不可解解的节点进行标记。如果初始解节点S0也被标记为不可解节点，则搜索失败，表明原始问题无解，退出搜索过程；如果不能确定S0为不可解节点，则从Open表中删去具有不可解先辈的节点。
    ③ 转第(2)步。  
```

---

【例子】 设有下图所示的与/或树，节点按标注顺序进行扩展，其中标有t1、t2、t3的节点是终止节点，A、B、C为不可解的端节点。
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E4%BE%8B%E5%AD%90.jpg)

本例中与/或树的广度优先搜索过程：

(1) 先扩展1号节点，生成2号节点和3号节点。 
(2) 扩展2号节点，生成A节点和4号节点。
(3) 扩展3号节点，生成t1节点和5号节点。由于t1为终止节点，则标记它为可解节点，并应用可解标记过程，不能确定3号节点是否可节。
(4)  扩展节点A，由于A是端节点，因此不可扩展。调用不可解标记过程。
(5) 扩展4号节点，生成t2节点和B节点。由于t2为终止节点，标记为可解节点，应用可解标记过程，可标记2号节点为可解，但不能标记1号节点为可解。
(6) 扩展5号节点，生成t3节点和C节点。由于t3为终止节点，标记它为可解节点，应用可解标记过程，可标记1号节点为可解节点。
(7) 搜索成功，得到由1、2、3、4、5号节点和t1、t2、t3节点构成的解树。

---

3、 与/或树的深度优先搜索

```
(1)把初始节点S0放入OPEN表中； 
(2)把OPEN表第一个节点取出放入CLOSED表，并记该节点为n； 
与/或树的深度优先搜索算法如下：
(3)如果节点n的深度等于dm，则转第(5)步的第①点； 
(4)如果节点n可扩展，则做下列工作： 
    ① 扩展节点n，将其子节点放入OPEN表的首部，并为每一个子节点设置指向父节点的指针；  
    ② 考察这些子节点中是否有终止节点。若有，则标记这些终止节点为可解节点，并用可解标记过程对其父节点及先辈节点中的可解解节点进行标记。如果初始解节点S0能够被标记为可解节点，就得到了解树，搜索成功；如果不能确定S0为可解节点，则从OPEN表中删去具有可解先辈的节点。
    ③ 转第(2)步。 
(5)如果节点n不可扩展，则作下列工作： 
    ① 标记节点n为不可解节点；
    ② 应用不可解标记过程对节点n的先辈中不可解解的节点进行标记。如果初始解节点S0也被标记为不可解节点，则搜索失败，表明原始问题无解，退出搜索过程；如果不能确定S0为不可解节点，则从Open表中删去具有不可解先辈的节点。
    ③ 转第(2)步。
```

4、 与/或树的启发式搜索

```
(1) 把初始节点S0放入OPEN表中；
(2) 求出希望树T，即根据当前搜索树中节点的代价h求出以S0为根的希望树T； 
(3) 依次在OPEN表中取出T的端节点放入CLOSED表，并记该节点为n；节点n有三种不同情况：
    ①n为终止节点，
    ②n不是终止节点，但可扩展，
    ③n不是终止节点，且不可扩展，
对三种情况分别进行步骤(4) (5) (6)的操作过程； 
(4)如果节点n为终止节点，则： 
    ① 标记节点n为可解节点；
    ② 在T上应用可解标记过程，对n的先辈节点中的所有可解解节点进行标记；
    ③ 如果初始解节点S0能够被标记为可解节点，则T就是最优解树，成功退出；
    ④ 否则，从OPEN表中删去具有可解先辈的所有节点。 
    ⑤ 转第(2)步。 
(5) 如果节点n不是终止节点，但可扩展，则： 
    ① 扩展节点n，生成n的所有子节点；
    ② 把这些子节点都放入OPEN表中，并为每一个子节点设置指向父节点n的指针；
    ③ 计算这些子节点及其先辈节点的h值；
    ④ 转第(2)步。
(6) 如果节点n不是终止节点，且不可扩展，则： 
    ① 标记节点n为不可解节点；
    ② 在T上应用不可解标记过程，对n的先辈节点中的所有不可解解节点进行标记；
    ③ 如果初始解节点S0能够被标记为不可解节点，则问题无解，失败退出；
    ④ 否则，从OPEN表中删去具有不可解先辈的所有节点。 
    ⑤ 转第(2)步。
```

5、 博弈树的启发式搜索
6、 α-β剪枝技术

>搜索的完备性与效率

**完备性**
* 对于一类 **可解的问题**和一个搜索过程，如果运用该搜索过程一定能求得该类问题的解，则称该搜索过程为 **完备**的，否则为不完备的。
* 完备的搜索过程称为“搜索算法”。不完备的搜索过程不是算法，称为“过程”。
* 广度优先搜索、代价树的广度优先搜索、改进后的有界深度优先搜索以及A*算法都是完备的搜索过程，其它搜索过程都是不完备的。

**搜索效率**
* 一个搜索过程的搜索效率不仅取决于过程自身的启发能力，而且还与被解问题的有关属性等多种因素有关。
* 为了比较求解同一问题的不同搜索方法的效率，常用以下两种指标来衡量：
    - **外显率**
    - **有效分支因数**

其中，外显率定义为：`P=L/T`；L为从初始节点到目标节点的路径长度；T为整个搜索过程中所生成的节点总数。
外显率反映了搜索过程中从初始节点向目标节点前进时 **搜索区域的宽度**。当`T=L`时，`P=1`，表示搜索过程中每次只生成一个节点，它恰好是解路径上的节点，搜索效率最高。P越小表示搜索时产生的无用节点愈多，搜索效率愈低。

有效分枝因数B定义为：`B+B^2+…+B^L=T`；B是有效分枝因数，它表示在整个搜索过程中 **每个节点平均生成的子节点数目**；L为从初始节点到目标节点的路径长度；T为整个搜索过程中所生成的节点总数。当`B＝1`时，`L=T`，此时所生成的节点数最少，搜索效率最高。


#### 自然演绎推理

从一组已知为真的事实出发，直接运用经典逻辑中的推理规则推出结论的过程称为自然演绎推理。
自然演绎推理最基本的推理规则是三段论推理，它包括：
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E8%87%AA%E7%84%B6%E6%BC%94%E7%BB%8E%E6%8E%A8%E7%90%86.jpg)

---

【例子】 设已知如下事实：
(1) 只要是需要编程序的课，王程都喜欢。
(2) 所有的程序设计语言课都是需要编程序的课。
(3) C是一门程序设计语言课。
求证：王程喜欢C这门课。

证明：
第一步，首先定义谓词
    `Prog(x)`：x是需要编程序的课。
    `Like(x, y)`: x喜欢y。
    `Lang(x)`: x是一门程序设计语言课
第二步，把已知事实及待求解问题用谓词公式表示如下：
    `Prog(x)→Like(Wang , x)`
    `(∀x)( Lang(x)→Prog(x))`
    `Lang(C)`
第三步，应用推理规则进行推理：
    `Lang(y)→Prog(y)`                                    全称固化
    `Lang(C)，Lang(y)→Prog(y) ⇒ Prog(C)`                 假言推理 {C/y}
    `Prog(C),  Prog(x)→Like(Wang , x) ⇒ Like(Wang , C)`  假言推理  {C/x}
因此，王程喜欢C这门课。

---

##### 注意避免以下两类错误：
* 肯定后件的错误：当`P→Q`为真时，希望通过肯定后件Q为真来推出前件P为真，这是不允许的。
* 否定前件的错误：当`P→Q`为真时，希望通过否定前件P来推出后件Q为假，这也是不允许的。

##### 自然演绎推理的优缺点
* 优点
    - 定理证明过程自然，易于理解，并且有丰富的推理规则可用。
* 缺点
    - 是容易产生知识爆炸，推理过程中得到的中间结论一般按指数规律递增，对于复杂问题的推理不利，甚至难以实现。


#### 消解演绎推理

一种基于 **鲁滨逊（Robinson）消解原理**的机器推理技术。鲁滨逊消解原理亦称为消解原理，是鲁滨逊于1965年在海伯伦（Herbrand）理论的基础上提出的一种基于逻辑的“反证法”。

>在人工智能中，几乎所有的问题都可以转化为一个定理证明问题。定理证明的实质，就是要对前提P和结论Q，证明`P→Q`永真。
>而要证明`P→Q`永真，就是要证明`P→Q`在任何一个非空的个体域上都是永真的。这将是非常困难的，甚至是不可实现的。

**鲁滨逊消解原理**把永真性的证明转化为关于 **不可满足性**的证明。即：要证明`P→Q`永真，只需证明`P∧¬Q`不可满足。（`¬(P→Q) ⇔ ¬(¬P∨Q) ⇔ P∧¬Q`）

##### 子句集及其化简

>鲁滨逊消解原理是在子句集的基础上讨论问题的。因此，讨论消解演绎推理之前，需要先讨论子句集的有关概念。

* 原子谓词公式及其否定统称为 **文字**。例如: P(x)、Q(x)、¬ P(x)、 ¬ Q(x)等都是文字。
* 任何文字的析取式称为 **子句**。例如，P(x)∨Q(x)，P(x，f(x))∨Q(x，g(x))都是子句。
* 不含任何文字的子句称为 **空子句**。
    - 由于空子句不含有任何文字，也就不能被任何解释所满足，因此 **空子句是永假的**，不可满足的。
    - 空子句一般被记为NIL。
* 由子句或空子句所构成的集合称为 **子句集**。
    - 在子句集中，子句之间是 **合取关系**；
    - 子句集中的变元受 **全称量词**的约束；
    - 任何谓词公式都可通过等价关系及推理规则化为相应的子句集。

把谓词公式化成子句集的步骤
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%8C%96%E5%AD%90%E5%8F%A5%E9%9B%86.jpg)

子句集的意义
在上述化简过程中，由于在消去存在量词时所用的Skolem函数可以不同，因此化简后的标准子句集是不唯一的。因此，当原谓词公式为非永假时，它与其标准子句集并不等价。但当原谓词公式为永假（或不可满足）时，其标准子句集则一定是永假的，即Skolem化并不影响原谓词公式的永假性。

不可满足性
对于任意论域中的任意一个解释，S中的子句不能同时取得真值T。

>定理：设有谓词公式F，其子句集为S，则F不可满足的充要条件是S不可满足。

* 由此定理可知，要证明一个谓词公式是不可满足的，只要证明其相应的标准子句集是不可满足的就可以了。
* 由于子句集中的子句之间是合取关系，**子句集中只要有一个子句为不可满足，则整个子句集就是不可满足的**。
* 空子句是不可满足的。因此，**一个子句集中如果包含有空子句，则此子句集就一定是不可满足的**。
* 这个定理是 **鲁滨逊消解原理的主要依据**。

##### 鲁滨逊消解原理

鲁滨逊消解原理的基本思想
* 首先把欲证明问题的 **结论否定**，并加入子句集，得到一个扩充的子句集S'；
* 然后设法检验子句集S'是否含有空子句，若含有空子句，则表明S'是不可满足的；若不含有空子句，则继续使用消解法，在子句集中选择合适的子句进行消解，**直至导出空子句或不能继续消解为止**。

鲁滨逊消解原理包括
* 命题逻辑的消解
* 谓词逻辑的消解

>命题逻辑的消解

消解推理的核心是求两个子句的 **消解式**。
* 设C1和C2是子句集中的任意两个子句，如果C1中的文字L1与C2中的文字L2 **互补**，那么可从C1和C2中分别消去L1和L2，并将C1和C2中余下的部分按析取关系构成一个新的子句C12，则称这一过程为 **消解**，称C12为C1和C2的 **消解式**，称C1和C2为C12的 **亲本子句**。

---

【例子】
1. 设C1=¬Q，C2=Q，则C1和C2的消解式C12 = NIL .
2. 设C1=P∨Q∨R，C2=¬P∨S，则C1和C2的消解式C12 = Q∨R∨S .
3. 设C1 =¬P ∨ Q ，C2=¬Q，C3=P，则C1、C2、C3的消解式C123 = NIL .

---

* 很显然，可以得出定理：**消解式C12是其亲本子句C1和C2的逻辑结论。**根据该定理，可以得到以下推论：
    - 推论1：设C1和C2是子句集S中的两个子句，C12是C1和C2的消解式，若用C12代替C1和C2后得到新的子句集S1，则由S1的不可满足性可以推出原子句集S的不可满足性。即：
    `S1的不可满足性⇔S的不可满足性`
    - 推论2：设C1和C2是子句集S中的两个子句，C12是C1和C2的消解式，若把C12加入S中得到新的子句集S2，则S与S2的不可满足性是等价的。即：
    `S2的不可满足性⇔S的不可满足性`

上述两个推论说明，*为证明子句集S的不可满足性，只要对其中可进行消解得子句进行消解，**并把消解式加入到子句集S中，或者用消解式代替他的亲本子句**，然后对新的子句集证明其不可满足性就可以了*。
如果经消解能得到空子句，根据空子句的不可满足性，即可得到原子句集S是不可满足的结论。
在命题逻辑中，对不可满足的子句集S，其消解原理是完备的。即：**子句集S是不可满足的，当且仅当存在一个从S到空子句的消解过程。**

应用消解原理证明定理的过程称为 **消解反演**。

**命题逻辑的消解反演：**
在命题逻辑中，已知F，证明G为真的消解反演过程如下：
1. 否定目标公式G，得¬G;
2. 把¬G并入到公式集F中，得到{F，¬G}；
3. 把{F，¬G}化为子句集S；
4. 应用消解原理对子句集S中的子句进行消解，并把每次得到的消解式并入S中。如此反复进行，若 **出现空子句**，则停止消解，此时就证明了G为真。

---

【例子】 设已知的公式集为`{P,(P∧Q)→R,(S∨T)→Q,T}`，求证：R为真。

解：假设结论R为假, 将¬R加入公式集，并化为子句集：
    `S={P,¬P∨¬Q∨R,¬S∨Q,¬T∨Q,T,¬R}`
其消解过程如下图的消解演绎树所示。
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%B6%88%E8%A7%A3%E6%A0%91.jpg)
该树根为空子句NIL，则子句集S不可满足，即假设有误，于是证得R为真。

---

>谓词逻辑的消解

* 在谓词逻辑中，由于子句集中的谓词一般都含有变元，因此不能象命题逻辑那样直接消去互补文字。
* 对于谓词逻辑，需要先用一个最一般合一对变元进行置换，然后才能进行消解。

设C1和C2是两个没有公共变元的子句，L1和L2分别是C1和C2中的文字。如果 σ 是L1和¬ L2存在的`最一般合一`，则称：
    `C12=({C1σ}-{ L1σ})∪({ C2σ}-{ L2σ})`
为C1和C2的二元消解式，L1和L2为消解式上的文字。

**注意**：在谓词逻辑的消解过程中，要注意以下几个问题：
1. 若C1和C2有相同的变元x，需要将其中一个变元更名。（例2）
2. 求消解式不能同时消去两个互补对，消去这两个互补文字所得的结果不是两个亲本子句的逻辑结论。(例3)
3. 对参加消解的某个子句，若其内部有可合一的文字，则在进行消解之前应先对这些文字进行合一，以实现这些子句内部的化简。(例4)

---

【例子】
例1、设`C1=P(a)∨R(x)`，`C2=¬P(y)∨Q(b)`，求 C12。
解：取`L1= P(a)`, `L2=¬P(y)`，则L1和¬L2的最一般合一是`σ={a/y}`。因此：

```
    C12 = ( {C1σ}-{L1σ}) ∪ ({C2σ}-{L2σ})
        = ({P(a), R(x)}-{P(a)})∪({¬P(a), Q(b)}-{¬P(a)})
        = ({R(x)})∪({Q(b)})
        = { R(x), Q(b) } 
        = R(x)∨Q(b)
```

例2、设`C1=P(x)∨Q(a)`，`C2=¬P(b)∨R(x) `，求 C12。
解：由于C1和C2有相同的变元x，不符合定义的要求。为了进行消解，需要修改C2中变元的名字。令`C2=¬P(b)∨R(y)`，此时`L1= P(x)`, `L2 =¬P(b)`，L1和¬L2的最一般合一是 `σ={b/x}`。则有:

```
    C12 = ({C1σ}-{L1σ})∪ ({C2σ}-{L2σ})
        = ({P(b), Q(a)}-{P(b)}) ∪ ({¬P(b), R(y)}-{¬P(b)})
        = ({Q(a)}) ∪ ({R(y)})
        = {Q(a), R(y)}
        = Q(a)∨R(y)
```

例3、设 `C1=P(a)∨¬Q(x)`，`C2=¬P(y)∨Q(b)`，求C12。
解：对C1和C2通过最一般合一（`σ={b/x, a/y}`）的作用，便得到空子句NIL的结论，从而得出C1、C2互相矛盾的结论，而事实上C1、C2并无矛盾。

例4、设 `C1=P(x)∨P(f(a))∨Q(x)` ，`C2=¬P(y)∨R(b)`，求C12。
解：本例的C1中有可合一的文字P(x)与P(f(a))，用它们的最一般合一`σ={f(a)/x}`进行代换，可得到 ： 
`C1σ=P(f(a))∨Q(f(a))`
此时对C1σ与C2进行消解。选`L1= P(f(a))`, `L2 =¬P(y)`，L1和L2的最一般合一是`σ={f(a)/y}`，则可得到C1和C2的二元消解式为：
`C12=R(b)∨Q(f(a))`

例5、设 `C1=P(y)∨P(f(x))∨Q(g(x))`、`C2=¬P(f(g(a)))∨Q(b)`，求C12。
解：对C1，取最一般合一` σ={f(x)/y}`，得C1的因子`C1σ=P(f(x))∨Q(g(x))`，对C1的因子和C2消解（`σ={g(a)/x }`），可得：`C12=Q(g(g(a)))∨Q(b)`

---

**谓词逻辑的消解反演：**
在谓词逻辑中，已知F，证明G是F的结论的消解反演过程如下：
1. 否定目标公式G，得¬G;
2. 把¬G并入到公式集F中，得到{F，¬G}；
3. 把{F，¬G}化为子句集S；
4. 应用消解原理对子句集S中的子句进行消解，并把每次得到的消解式并入S中。如此反复进行，若出现空子句，则停止消解，此时就证明了G为真。

与命题逻辑的消解反演过程比较一下
* 步骤基本相同，但每步的处理对象不同。
* 在步骤(3)化简子句集时，谓词逻辑需要把由谓词构成的公式集化为子句集。
* 在步骤(4)按消解原理进行消解时，谓词逻辑的消解原理需要考虑两个亲本子句的最一般合一。

---

【例子】
例1、已知`F:(∀x)((∃y)(A(x, y)∧B(y))→(∃y)(C(y)∧D(x, y)))`、`G:¬(∃x)C(x)→(∀x)(∀y)(A(x, y)→¬B(y))`，求证G是F的逻辑结论。

证明：
第一步，先把G否定，并放入F中，得到的`{F,¬G}`：
    `{(∀ x)((∃ y)(A(x,y)∧B(y))→(∃ y)(C(y)∧D(x,y)))`，`¬(¬(∃ x)C(x)→(∀ x)(∀ y)(A(x,y)→¬ B(y)))}`
第二步，把{F,¬G}化成子句集，得到
    (1) `¬A(x,y)∨¬B(y)∨C(f(x))`
    (2) `¬A(u,v)∨¬B(v)∨D(u,f(u))`
    (3) `¬C(z)`
    (4) `A(m,n)`
    (5) `B(k)`
第三步，应用谓词逻辑的消解原理对上述子句集进行消解，其过程为：
    (6) `¬ A(x,y)∨¬ B(y)`    *(1)和(3)消解，取σ={f(x)/z}*
    (7) `¬ B(n) `             *(4)和(6)消解，取σ={m/x,n/y}*
    (8) `NIL`                  *(5)和(7)消解，取σ={n/k}*
最后，“G是F的逻辑结论”得证。

上述消解过程可用如下消解树来表示
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%B6%88%E8%A7%A3%E6%A0%912.jpg)

例2、**“快乐学生”问题**
假设：任何通过计算机考试并获奖的人都是快乐的，任何肯学习或幸运的人都可以通过所有考试，张不肯学习但他是幸运的，任何幸运的人都能获奖。
求证：张是快乐的。

证明：(完整的解题过程)
第一步，先定义谓词：
    Pass(x, y)：x可以通过y考试
    Win(x, prize)：x能获得奖励
    Study(x) ：x肯学习
    Happy(x)：x是快乐的
    Lucky(x) ：x是幸运的
第二步，将已知条件以及结论的否定用谓词表示如下：
    “任何通过计算机考试并奖的人都是快乐的”
            `(∀x)(Pass(x, computer)∧Win(x, prize)→Happy(x))`
    “任何肯学习或幸运的人都可以通过所有考试”
            `(∀x)(∀y)(Study(x)∨Lucky(x)→Pass(x, y))`
    “张不肯学习但他是幸运的”
            `¬Study(zhang)∧Lucky(zhang)`
    “任何幸运的人都能获奖”
            `(∀x)(Lucky(x)→Win(x, prize))`
    结论“张是快乐的”的否定
            `¬Happy(zhang)`
第三步，将上述谓词公式转化为子句集如下：
    1. `¬Pass(x, computer)∨¬Win(x, prize)∨Happy(x)`
    2. `¬Study(y)∨Pass(y, z)`
    3. `¬Lucky(u)∨Pass(u, v)`
    4. `¬Study(zhang)`
    5. `Lucky(zhang)`
    6. `¬Lucky(w)∨Win(w, prize)`
    7. `¬ Happy(zhang)`    (结论的否定)
第四步，按消解原理进行消解，消解树如下：
    ![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%B6%88%E8%A7%A3%E6%A0%913.jpg)
最后，“张是快乐的”得证。

---

##### 消解反演推理的消解策略

>在消解演绎推理中，由于事先并不知道哪些子句对可进行消解，更不知道通过对哪些子句对的消解能尽快得到空子句，因此就需要对子句集中的所有子句逐对进行比较，直到得出空子句为止。这种盲目的全面进行消解的方法，不仅会产生许多无用的消解式，更严重的是会产生组核爆炸问题。因此，需要研究有效的消解策略来解决这些问题。

常用的消解策略可分为两大类：
* 限制策略：通过限制参加消解的子句减少盲目性
* 删除策略：通过删除某些无用的子句缩小消解范围

##### 用消解反演求取问题的答案

消解原理除了可用于 **定理证明**外，还可用来 **求取问题答案**，其思想与定理证明相似。
其一般步骤为：
1. 把问题的已知条件用谓词公式表示出来，并化为子句集；
2. 把问题的目标的否定用谓词公式表示出来，并化为子句集；
3. 对目标否定子句集中的每个子句，构造该子句的重言式（即把该目标否定子句和此目标否定子句的否定之间再进行析取所得到的子句），用这些重言式代替相应的目标否定子句式，并把这些重言式加入到前提子句集中，得到一个新的子句集；
4. 对这个新的子句集，应用消解原理求出其证明树，这时证明树的根子句不为空，称这个证明树为修改的证明树；
5. 用修改证明树的根子句作为回答语句，则答案就在此根子句中。

---

【例子】
例1、已知：“张和李是同班同学，如果x和y是同班同学，则x的教室也是y的教室，现在张在302教室上课。”
问：“现在李在哪个教室上课？”

解：第一步，首先定义谓词
    `C(x, y)`：x和y是同班同学
    `At(x, u)`：x在u教室上课。
第二步，把已知前提用谓词公式表示如下：
    `C(zhang, li)`
    `(∀x)(∀y)(∀u)(C(x, y)∧At(x, u)→At(y,u))`
    `At(zhang, 302)`   
把目标的否定用谓词公式表示如下：
    `¬(∃v)At(li, v) `
第三步，把上述表示前提的谓词公式化为子句集：          
    `C(zhang, li)`
    `¬C(x, y)∨¬At(x, u)∨At(y, u)`
    `At(zhang, 302)`
把目标的否定化成子句式，并用下面的 **重言式**代替：
         `¬At(li,v) ∨At(li,v)`
第四步，把此 **重言式**加入前提子句集中，得到一个新的子句集，对这个新的子句集，应用消解原理求出其证明树。
求解过程如下图所示。该证明树的根子句就是所求的答案，即“李明在302教室”。
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%B6%88%E8%A7%A3%E6%A0%914.jpg)

例2、已知：A,B,C三人中有人从不说真话，也有人从不说假话。某人向这三人分别提出同一个问题：谁是说谎者？
    A答：“B和C都是说谎者”；
    B答：“A和C都是说谎者”；
    C答：“A和B中至少有一个是说谎者”。
问：求谁是老实人，谁是说谎者？

解：第一步，首先定义谓词
`T(x)`：表示x说真话
第二步，把已知前提用谓词公式表示如下：
    有人从不说真话：`¬T(C)∨¬T(A)∨¬T(B)`
    有人从不说假话：`T(C)∨T(A)∨T(B)`  
根据“A答：B和C都是说谎者”，则
    若A说真话：`T(A)→¬T(B)∧¬T(C)`    
    若A说假话： `¬T(A)→T(B)∨T(C)`
同理，根据“B答：A和C都是说谎者”，则
    `T(B)→¬T(A)∧¬T(C)`    
    `¬T(B)→T(A)∨T(C)`     
根据“C答：A和B中至少有一个是说谎者”，则
    `T(C)→¬T(A)∨¬T(B)`
    `¬T(C)→T(A)∧T(B)`
第三步，把上述公式化成子句集，得到前提子句集S：
    `¬T(A)∨¬T(B)`
    `¬T(A)∨¬T(C)`
    `T(C)∨T(A)∨T(B)`
    `¬T(B)∨¬T(C)`
    `¬T(C)∨¬T(A)∨¬T(B)`
    `T(A)∨T(C)`
    `T(B)∨T(C)`
第四步，先求谁是老实人，结论的否定为：`¬(∃x)T(x)`，把目标的否定化成子句式，并用下面的重言式代替：
    `¬T(x)∨T(x)`
把此重言式加入前提子句集S，得到一个新子句集。
第五步，对这个新的子句集，应用消解原理求出其证明树。
    ![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%B6%88%E8%A7%A3%E6%A0%915.jpg)
第六步，同理证明A不是老实人，结论的否定为： ¬T(A)，将结论的否定¬(¬T(A)) 加入并入前提子句集S中，应用消解原理对新的子句集进行消解：
    ![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%B6%88%E8%A7%A3%E6%A0%916.jpg)

---

##### 消解演绎推理的优缺点：
* 优点：
    - 简单，便于在计算机上实现。
* 缺点：
    - 必须把逻辑公式化成子句集。
    - 不便于阅读与理解：¬P(x)∨Q(x)没有P(x)→Q(x)直观。
    - 可能丢失控制信息，如下列逻辑公式，化成子句后都是: A∨B∨C
```
    (¬A∧¬B)→C    ¬A→(B∨C)
    (¬A∧¬C)→B    ¬B→(A∨C)
    (¬C∧¬B)→A    ¬C→(B∨A)
```

#### 基于规则的演绎推理

>在消解演绎推理中，需要把谓词公式化为子句形，这使得原来蕴含在谓词公式中的一些重要信息却会在求取子句形的过程中被丢失。
>在不少情况下人们多希望使用接近于问题原始描述的形式来进行求解，而不希望把问题描述化为子句集。

基于规则的演绎推理又称为与/或形演绎推理，不再把有关知识转化为子句集，而是把领域知识及已知事实分别用蕴含式及与/或形表示出来，然后通过运用蕴含式进行演绎推理，从而证明某个目标公式。

规则是一种比较接近于人们习惯的问题描述方式，按照 **蕴含式**（“If →Then”规则）这种问题描述方式进行求解的系统称为基于规则的系统，或者叫做 **规则演绎系统**。

规则演绎系统按照推理方式可分为：
* 规则正向演绎系统
* 规则逆向演绎系统(ppt-14)
* 规则双向演绎系统(ppt-14)

##### 规则正向演绎系统

首先说明一下，在规则正向演绎系统中，对已知事实和规则都有一定的要求，如果不是所要求的形式，需要进行变换。

事实表达式的与或形变换
* 在基于规则的正向演绎系统中，把事实表示为非蕴含形式的与或形，作为系统的总数据库；
* 把一个公式化为与或形的步骤与化为子句集类似，只是不必把公式化为子句的合取形式，也不能消去公式中的合取。

详细来说，把事实表达式化为非蕴含形式的与/或形的步骤如下：
1. 利用 “P→Q⇔﹁P∨Q”，消去蕴含符号； 
2. 利用狄.摩根定律及量词转换率把“﹁”移到紧靠谓词的位置，直到否定符号的辖域最多只含一个谓词为止；
3. 重新命名变元，使不同量词约束的变元有不同的名字；
4. 对存在量词量化的变量用skolem函数代替；
5. 消去全称量词，且使各主要合取式中的变元具有不同的变量名。

---

【例子】
有如下表达式
        `(∃x) (∀y)(Q(y, x)∧﹁((R(y)∨P(y))∧S(x, y)))`
可把它转化为：
        `Q(z, a)∧(  ( ﹁R(y)∧﹁P(y) )∨﹁S(a, y)  )`
这就是 **与/或形表示**，也可用一棵与/或图表示出来。
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E4%B8%8E%E6%88%96%E5%BD%A2%E6%A0%91.jpg)

---

>关于 **与/或图**说明以下几点：

* 当某表达式为k个子表达式的析取：`E1∨E2∨…∨Ek`，其中每个子表达式Ei均被表示为`E1∨E2∨…∨Ek`的后继节点，并由一个k线连接符（即图中的半圆弧）将这些后继节点都连接到其父节点，即表示成与的关系。
* 当某表达式为k个子表达式的合取：`E1∧E2∧…∧Ek`，其中的每个子表达式Ei均被表示为`E1∧E2∧…∧Ek`的一个单一的后继节点，无需用连接符连接，即表示成或的关系。
* **这样，与/或图的根节点就是整个事实表达式，叶节点均为事实表达式中的一个文字**。

>有了与/或图的表示，就可以求出其解树（结束于文字节点上的子树）集。可以发现，事实表达式的子句集与解树集之间存在着一一对应关系，即 **解树集中的每个解树都对应着子句集中的一个子句**。
>**解树集中每个解树的端节点上的文字的析取就是子句集中的一个子句。**

上面那个与/或图有3个解树，分别对应这以下3个子句：
    `Q(z, a)`、`﹁R(y)∨ ﹁ S(a, y)`、`﹁P(y)∨ ﹁ S(a, y)`

>还需要注意以下两点：
* 这里的与/或图是作为综合数据库的一种表示，其中的变量受全称量词的约束。
* 在之前 问题归约表示 中所描述的 **与/或图表示方法**与这里 **与/或形的与/或图表示**有着不同的目的和含义，因此应用时应加以 **区分**。 


> 规则的表示

为简化演绎过程，通常要求规则具有如下形式：`L→W`，其中，L为单文字，W为与/或形公式。
(之所以限制前件L为单文字，是因为在进行正向演绎推理时要用规则作用于表示事实的与/或树，而该与/或树的叶节点都是单文字，这样就可用规则的前件与叶节点进行简单匹配。对非单文字情况，若形式为L1∨L2→W，则可将其转换成与之等价的两个规则L1→W与 L2→W进行处理。)

* 假定出现在蕴含式中的任何变量全都受全称量词的约束，并且这些变量已经被换名，使得他们与事实公式和其他规则中的变量不同。
* 如果领域知识的规则表示形式与上述要求不同，则应将它转换成要求的形式。

>将规则转换为要求形式的步骤：

1、 暂时消去蕴含符号“→”。设有如下公式：
        `(∀x)(((∃y) (∀ z)P(x, y,z))→(∀u)Q(x, u))`
运用等价关系“P→Q⇔﹁P∨Q”，可将上式变为：
        `(∀x)(﹁((∃ y) (∀z)P(x, y,z))∨(∀u)Q(x, u))`
2、 把否定符号“﹁”移到紧靠谓词的位置上，使其作用域仅限于单个谓词。通过使用狄.摩根定律及量词转换律可把上式转换为：
        `(∀ x)( (∀y) (∃z)﹁P(x, y,z))∨ (∀u)Q(x, u))`
3、 引入Skolem函数，消去存在量词。消去存在量词后，上式可变为：
        `(∀ x)( (∀y) (﹁P(x, y,f(x,y)))∨(∀u)Q(x, u))`
4、 把所有全称量词移至前面化成前束式，消去全部全称量词。消去全称量词后，上式变为：
        `﹁P(x, y,f(x,y))∨Q(x, u)`
此公式中的变元都被视为受全称量词约束的变元。
5、 恢复蕴含式表示。利用等价关系“`﹁P∨Q⇔P→Q`”将上式变为：
        `P(x, y,f(x,y))→Q(x, u)`

>目标公式的表示形式

* 与/或树正向演绎系统要求目标公式用子句形表示。如果目标公式不是子句形，则需要化成子句形。

>推理过程

规则正向演绎推理过程是从已知事实出发，不断运用规则，推出欲证明目标公式的过程。
先用与/或树把已知事实表示出来，然后再用规则的前件和与/或树的叶节点进行匹配，并通过一个匹配弧把匹配成功的规则加入到与/或树中，依此使用规则，直到产生一个含有以目标节点为终止节点的解树为止。

>下面分命题逻辑和谓词逻辑两种情况来讨论规则正向演绎过程。

**命题逻辑的规则正向演绎过程**
已知事实：`A∨B`
规则：`r1: A→C∧D`，`r2:  B→E∧G`
目标公式：`C∨G`

证明：
1）先将已知事实用与/或树表示出来；
2）然后再用匹配弧把r1和r2分别连接到事实与/或树中与r1和r2 的前件匹配的两个不同端节点；
3) 由于出现了以目标节点为终节点的解树，故推理过程结束。这一证明过程可用下图表示。
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E8%BF%87%E7%A8%8B%E5%9B%BE.jpg)

**谓词逻辑的规则正向演绎过程**
已知事实的与/或形表示：P(x, y)∨(Q(x)∧R(v, y))
规则：P(u, v)→(S(u)∨N(v)) 
目标公式：S(a)∨N(b)∨Q(c)

证明：
在谓词逻辑情况下，由于事实、规则及目标中均含有变元，因此，其规则演绎过程还需要用最一般合一对变进行置换。证明过程可用下图表示。
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E8%BF%87%E7%A8%8B%E5%9B%BE2.jpg)

#### 产生式系统

##### 基本结构

产生式系统的 **基本结构**由 **数据库**、**产生式规则**和 **控制策略**三部分构成。

* 总数据库：存放求解问题的各种当前信息，如：问题的初始状态，输入的事实，中间结论及最终结论等。
    - 推理过程中，当规则库中某条规则的前提可以和总数据库的已知事实匹配时，该规则被激活，由它推出的结论将被作为新的事实放入总数据库，成为后面推理的已知事实。
* 产生式规则：是一个规则库，也称知识库 。用于存放与求解问题有关的所有规则的集合。
* 控制策略：亦称推理机，用于控制整个产生式系统的运行，决定问题求解过程的推理线路。
    - 控制系统的主要任务包括： 选择匹配、 冲突消解、 执行操作、 终止推理、 路径解释...

##### 产生式系统的推理

产生式系统的推理分为 **正向推理**、**逆向推理**和 **双向推理**三种形式。

##### 主要优缺点

产生式系统的主要 **优缺点**
* 优点：
    - 自然性：采用“如果……，则……”的形式，人类的判断性知识基本一致。
    - 模块性：规则是规则库中最基本的知识单元，各规则之间只能通过总数据库发生联系，而不能相互调用，从而增加了规则的模块性。
    - 有效性：产生式知识表示法既可以表示确定性知识，又可以表示不确定性知识，既有利于表示启发性知识，又有利于表示过程性知识。
* 缺点：
    - 效率较低：各规则之间的联系必须以总数据库为媒介。并且，其求解过程是一种反复进行的“匹配—冲突消解—执行”过程。这样的执行方式将导致执行的低效率。
    - 不便于表示结构性知识：由于产生式表示中的知识具有一致格式，且规则之间不能相互调用，因此那种具有结构关系或层次关系的知识则很难以自然的方式来表示。


### 非经典推理

#### 经典推理和非经典推理
##### 非经典推理
现实世界中的大多数问题存在随机性、模糊性、不完全性和不精确性。对于这些问题，若采用前面所讨论的精确性推理方法显然是无法解决的。
为此，出现了一些新的逻辑学派，称为非经典逻辑，相应的推理方法称为 **非经典推理**。包括非单调性推理、不确定性推理、概率推理和贝叶斯推理等。

##### 非经典逻辑推理与经典逻辑推理的区别
* 在推理方法上，经典逻辑采用演绎逻辑推理，非经典逻辑采用归纳推理。
* 在辖域取值上，经典逻辑是二值逻辑，非经典逻辑是多值逻辑。
* 在运算法则上，两者大不相同。
* 在逻辑运算符上，非经典逻辑有更多的逻辑运算符。
* 在单调性上，经典逻辑是单调的，即已知事实均为充分可信的，不会随着新事实的出现而使原有事实变为假。非经典逻辑是非单调的。


#### 不确定性推理
##### 不确定性推理的概念
* 不确定性推理是建立在非经典逻辑基础上的一种推理，它是对不确定性知识的运用与处理。
* 不确定性推理泛指除精确推理以外的其它各种推理问题。包括不完备、不精确知识的推理，模糊知识的推理，非单调性推理等。
* 不确定性推理从不确定性的初始证据（即事实）出发，通过运用不确定性的知识，最终推出具有一定程度不确定性的结论。

##### 为什么要采用不确定性推理
* 所需知识不完备或问题的背景知识不足
* 所需知识描述不精确或模糊
* 多种原因导致同一结论或解题方案不唯一

##### 不确定性推理的基本问题
1. 不确定性的表示
2. 不确定性的匹配
3. 组合证据的不确定性的计算
4. 不确定性的更新
5. 不确定性结论的合成

##### 知识的不确定性的表示
* 考虑因素：1. 问题描述能力; 2. 推理中不确定性的计算
* 含义：知识的确定性程度，或静态强度
* 表示：
    - 概率，[0,1]，0接近于假，1接近于真
    - 可信度，[-1,1]，大于0接近于真，小于0接近于假

##### 证据的非精确性表示
* 证据来源：初始证据，中间结论
* 表示：用概率或可信度

##### 不确定性的匹配
* 含义：不确定的前提条件与不确定的事实匹配
* 问题：前提是不确定的，事实也是不确定的
* 方法：设计一个计算相似程度的算法，给出相似的限度
* 标志：相似度落在规定限度内为匹配，否则为不匹配

##### 组合证据不确定性的计算
* 含义：知识的前提条件是多个证据的组合
* 方法：**T(E)表示证据E为真的程度**
    - 最大最小法：
    `T(E1 AND E2)=min{T(E1),T(E2)}`
    `T(E1 OR E2)=max{T(E1),T(E2)}`
    - 概率法：在事件之间完全独立时使用
    `T(E1 AND E2)=T(E1)T(E2)`
    `T(E1 OR E2)=T(E1)＋T(E2)－T(E1)T(E2)`
    - 有界法：
    `T(E1 AND E2)=max{0,T(E1)＋T(E2)－1}`
    `T(E1 OR E2)=min{1,T(E1)＋T(E2)}`

##### 不确定性的更新
* 主要问题：解决不确定性知识在推理的过程中，知识不确定性的累积和传递。
* 解决方法
    - 已知规则前提证据E的不确定性`T(E)`和规则的强度`F(E,H)`，则结论H的不确定性：`T(H) = g1[T(E),F(E,H)] `
    - 证据合取： `T(E1 AND E2) = g2[T(E1), T (E2)] `
    - 证据析取： `T(E1   OR  E2) = g3[T(E1), T (E2)] `

##### 不确定性结论的合成
* 主要问题：多个不同知识推出同一结论，且不确定性程度不同
* 解决方法：
    - 并行规则算法：根据独立证据E1和E2分别求得结论H的不确定性为`T1(H)`和`T2(H)`，则证据E1和E2的组合导致结论H的不确定性：`T(H)=g[T1(H), T2(H)]`
    - 函数g视不同推理方法而定

#### 概率推理
##### 概率论基础回顾

* [全概率公式](https://baike.baidu.com/item/%E5%85%A8%E6%A6%82%E7%8E%87%E5%85%AC%E5%BC%8F)
* [贝叶斯(Bayes)公式](https://baike.baidu.com/item/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%85%AC%E5%BC%8F/9683982)

##### 概率推理方法
* 设有如下产生式规则：IF  E   THEN   H
    - 其中，E为前提条件，H为结论。
    - 条件概率P(H|E)可以作为在证据E出现时结论H的确定性程度，即规则的静态强度。
* 把贝叶斯方法用于不精确推理的思想
    - 已知前提E的概率P(E)和结论H的先验概率P(H)
    - 已知H成立时E出现的条件概率P(E|H)
    - 利用规则推出H在E出现的条件下的后验概率：
    ![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%85%AC%E5%BC%8F.jpg)
* 对于一组产生式规则：IF  E   THEN  Hi
    - 一个前提条件E支持多个结论H1, H2, ...,Hn
    - 同样有后验概率如下（ Hi 确定性的程度，或规则的静态强度）：
    ![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%85%AC%E5%BC%8F2.jpg)
* 对于有多个证据E1, E2, …, Em和多个结论H1, H2, ..., Hn,并且每个证据都以一定程度支持结论的情况，上面的式子可进一步扩展为:
    ![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%85%AC%E5%BC%8F3.jpg)

---

【例子】
设H1,H2,H3分别是三个结论，E是支持这些结论的证据。已知：
```
P(H1)=0.3
P(H2)=0.4
P(H3)=0.5
P(E|H1)=0.5
P(E|H2)=0.3
P(E|H3)=0.4
```
求P(H1|E),P(H2|E)及P(H3|E)的值各是多少？

解：
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%85%AC%E5%BC%8F4.jpg)
同理可得：
P(H2|E)=0.26
P(H3|E)=0.43
观察：( 注：P(E)=0.47 )
P(H1)=0.3 , P(E|H1)=0.5     P(H1|E)=0.32 
P(H2)=0.4 , P(E|H2)=0.3     P(H2|E)=0.26
P(H3)=0.5 , P(E|H3)=0.4     P(H3|E)=0.43
结论：由于E的出现，H1成立的可能性增加，H2和H3成立的可能性不同程度的下降。

---

##### 概率推理方法的特点
* 优点：
    - 概率推理方法有较强的理论背景和良好的数学特性，当证据彼此独立时计算的复杂度比较低。
* 缺点：
    - 概率推理方法要求给出结论Hi的先验概率P(Hi)及条件概率 P(Ej|Hi)。

#### 贝叶斯推理（主观贝叶斯方法）

>使用概率推理方法求结论Hi在存在证据E时的条件概率P(Hi|E) ，需要给出结论Hi的先验概率P(Hi)及证据E的条件概率 P(E|Hi)。这对于实际应用是不容易做到的。
>Duda 和 Hart 等人在贝叶斯公式的基础上，于1976年提出主观贝叶斯方法，建立了不精确推理的模型，并把它成功地应用于PROSPECTOR专家系统（PROSPECTOR是国际上著名的一个用于勘察固体矿的专家系统）。

##### 主观贝叶斯方法(ppt-24)
* 知识不确定性的表示

    - 在主观Bayes方法中，知识是用产生式表示的，其形式为：
    `IF  E  THEN  (LS, LN)   H` 
    - E表示规则前提条件，它既可以是一个简单条件，也可以是用AND或OR把多个简单条件连接起来的复合条件。
    - H是结论，用P(H)表示H的先验概率，它指出没有任何专门证据的情况下结论H为真的概率，其值由领域专家根据以往的实践经验给出。

    - LS是规则的充分性度量。用于指出E对H的支持程度，取值范围为[0,+∞)，其定义为：
    ![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%85%AC%E5%BC%8F5.jpg)
    - LN是规则的必要性度量。用于指出E对H为真的必要程度，即﹁E对对H的支持程度。取值范围为[0,+∞)，其定义为：
    ![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%85%AC%E5%BC%8F6.jpg)
* 证据不确定性的表示
* 组合证据不确定性的计算
* 不确定性的更新
* 主观贝叶斯方法的推理过程

#### 可信度方法

> 什么是可信度

* 可信度是指人们根据以往经验对某个事物或现象为真的程度的一个判断，或者说是人们对某个事物或现象为真的相信程度。
* 在可信度方法中，由专家给出规则或知识的可信度，从而 **避免对先验概率、条件概率的要求**。
* 可信度方法是肖特里菲（Shortliffe）等人在确定性理论基础上结合概率论等理论提出的一种不精确推理模型。

该方法 **直观**、**简单**而且 **效果好**，在专家系统等领域获得了较为广泛的应用。

>C-F模型

C-F模型：基于可信度表示的不确定性推理的基本方法，其他可信度方法都是基于此发展而来。

>知识的不确定性表示

知识的不确定性表示：在C-F模型中，知识是用产生式规则表示的，其一般形式为：
                 `IF   E   THEN   H (CF(H, E))`
`E`：知识的前提条件，可以是单一或复合条件；
`H`：知识的结论，可以是单一结论或多个结论；
`CF(H, E)`：知识的可信度，称为 **可信度因子**(Certainty Factor)或规则强度。

一般情况下，CF(H, E)的取值为[-1, 1]，表示当证据E为真时，对结论H的支持程度。其值越大，表示支持程度越大。
* CF(H,E)>0对应于P(H|E)>P(H)；
* CF(H,E)=0对应于P(H|E)=P(H)；
* CF(H,E)<0对应于P(H|E)<P(H)。

例如：`IF   发烧  AND  流鼻涕   THEN   感冒(0.7)`，表示当某人确实有“发烧”及“流鼻涕”症状时，则有七成的把握是患了感冒。

>CF(H,E)的定义:

`CF(H,E) = MB(H,E) - MD(H,E)`

* MB ( Measure Belief ) 称为信任增长度，反映了证据对结论有利的一面。MB(H, E)定义为：
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%85%AC%E5%BC%8F7.jpg)
* MD ( Measure Disbelief ) 称为不信任增长度，MD反映了证据对结论不利的一面。MD(H,E)定义为：
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%85%AC%E5%BC%8F8.jpg)

>MB和MD的关系：

* 当`P(H|E)>P(H)`时： E的出现增加了H的概率
`MB(H,E)>0，MD(H,E)=0` 
* 当`P(H|E)<P(H)`时： E的出现降低了H的概率
`MB(H,E) =0，MD(H,E)>0`
因此，CF(H, E)的计算公式：
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%85%AC%E5%BC%8F9.jpg)

>可信度的性质(ppt-25)

* 互斥性：对同一证据，不可能既增加对H的信任程度，又同时增加对H的不信任程度，即MB与MD是互斥的
    - 当MB(H, E)>0时，MD(H, E)=0
    - 当MD(H, E)>0时，MB(H, E)=0
* 值域：MB(H, E) ∈ [0,1]; MD(H, E) ∈ [0,1]; CF(H, E) ∈[-1,1],
    - 当且仅当P(H|E)=1时,  CF(H,E)=1 
    - 当且仅当P(H|E)=0时,  CF(H,E)=-1
    - CF(H,E)定性地反映了P(H|E)的大小，因此可以用CF(H,E)近似表示P(H|E) ，描述规则的可信度。
* 对H的信任增长度等于对非H的不信任增长度
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%85%AC%E5%BC%8F10.jpg)
* 再根据CF的定义和MB、MD的互斥性有 
` CF(H,E)+CF(﹁H,E)=0`
* 对前提E，若支持若干个不同的结论Hi(i=1,2,…,n)，则
* 因此，如果发现专家给出的知识有如下情况
`CF(H1, E)=0.7,  CF(H2, E)=0.4`
* 则因0.7+0.4=1.1>1为非法，应进行调整或规范化。

>证据不确定性的表示

* 证据的E不确定性也用可信度因子CF(E)表示
* CF(E)的取值范围：[-1，+1]。 
    - CF(E)=1，证据E肯定它为真
    - CF(E)=-1，证据E肯定它为假
    - CF(E)=0，对证据E一无所知
    - 0<CF(E)<1，证据E以CF(E)程度为真
    - -1<CF(E)<0，证据E以CF(E)程度为假

>否定证据的不确定性计算

`CF(¬E)=－CF(E)`

>组合证据的不确定性计算

* 可采用最大最小法
    - 当组合证据E是多个单一证据的合取时，若已知`CF(E1), …, CF(En)`，则:
    `CF(E)=min{CF(E1), CF(E2), … ,CF(En)}`
    - 当组合证据E是多个单一证据的析取时，若已知`CF(E1), …, CF(En)`，则:
    `CF(E)=max{CF(E1), CF(E2), … ,CF(En)}` 

>不确定性的更新

`IF   E   THEN   H  (CF(H, E))　`

>结论H的可信度由下式计算：  

`CF(H)=CF(H,E)×max{0,CF(E)}`

* CF(H)的取值范围：[-1，+1]。 
    - CF(H)=0: CF(E)<0,即该模型没考虑E为假对H的影响
    - CF(H)>0: 表示结论以某种程度为真
    - CF(H)<0: 表示结论以某种程度为假

>结论不确定性的合成

* 若由多条不同知识推出了相同的结论，但可信度不同，则用合成算法求出综合可信度。设有知识： 
`IF  E1   THEN   H  (CF(H, E1))`
`IF  E2   THEN   H  (CF(H, E2))`
* 则结论H 的综合可信度可分以下两步计算：
(1)、分别对每条知识求出其CF(H)。即
 `CF1(H)=CF(H, E1) ×max{0, CF(E1)}`
 `CF2(H)=CF(H, E2) ×max{0, CF(E2)}`

>结论不确定性的合成

(2)、用如下公式求E1与E2对H的综合可信度 
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%85%AC%E5%BC%8F11.jpg)

---

【例子】
设有如下一组知识：
```
r1：IF  E1  THEN  H  (0.9)
r2：IF  E2  THEN  H  (0.6)
r3：IF  E3  THEN  H  (-0.5)
r4：IF  E4  AND  ( E5  OR  E6)  THEN  E1  (0.8)
```
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%8F%AF%E4%BF%A1%E5%BA%A6%E4%BE%8B%E5%AD%90.jpg)
已知：`CF(E2)=0.8`，`CF(E3)=0.6`，`CF(E4)=0.5`，`CF(E5)=0.6`,`CF(E6)=0.8`，求：`CF(H)`。

解：由r4得到：
```
 CF(E1) = 0.8×max{0, CF(E4  AND  (E5  OR   E6))}
        = 0.8×max{0, min{CF(E4),  CF(E5  OR   E6)}} 
        = 0.8×max{0, min{CF(E4),  max{CF(E5),  CF(E6)}}}
        = 0.8×max{0, min{CF(E4),  max{0.6,  0.8}}}
        = 0.8×max{0, min{0.5,  0.8}}
        = 0.8×max{0,  0.5} 
        = 0.4 
 由r1得到：
    CF1(H) = CF(H, E1)×max{0,  CF(E1)}
           = 0.9×max{0,  0.4} 
           = 0.36

 由r2得到：
    CF2(H) = CF(H, E2)×max{ 0,  CF(E2) }
      　   = 0.6×max{ 0,  0.8 } 
           = 0.48
由r3得到：
    CF3(H) = CF(H, E3)×max{ 0,  CF(E3) }
      　   = -0.5×max{ 0,  0.6 } 
      　   = -0.3
```
根据结论不精确性的合成算法，CF1(H)和CF2(H)同号，有：
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%85%AC%E5%BC%8F12.jpg)
CF12(H)和CF3(H)异号，有：
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E5%85%AC%E5%BC%8F13.jpg)
综合可信度为CF(H)=0.53。

---

#### 证据理论(ppt-25-21)


### 专家系统

>专家系统的先行者费根鲍姆（Feigenbaum）曾把专家系统定义为一个应用知识和推理过程来求解那些需要大量的人类专家解决难题经验的智能计算机程序。
>专家系统主要指的是一个智能计算机程序系统，其内部含有大量的某个领域专家水平的知识与经验，能够利用人类专家的知识和解决问题的经验方法来处理该领域的高水平难题。

#### 专家系统概述
* 专家系统是一个具有大量的专门知识与经验的程序系统，它应用人工智能技术和计算机技术，根据某领域一个或多个专家提供的知识和经验，进行推理和判断，模拟人类专家的决策过程，以便解决那些需要人类专家才能处理好的复杂问题。简而言之，专家系统是一种模拟人类专家解决领域问题的计算机程序系统。
* 专家系统的基本功能取决于它所含有的知识，因此，有时也把专家系统称为基于知识的系统（knowledge-based system）。

##### 专家系统的特点
* 启发性
    - 专家系统要解决的问题，其结构往往是不合理的，其问题求解（problem-solving）知识不仅包括理论知识和常识，而且包括专家本人的启发知识。
    - 能运用专家的知识和经验进行推理、判断和决策。
* 透明性
    - 专家系统能够解释本身的推理过程和回答用户提出的问题，以便让用户了解推理过程，提高对专家系统的信赖感。
    - 问题求解过程中知识应用的合理性可由检验专家系统的解释推理路径来验证。
* 灵活性
    - 专家系统的灵活性是指它的扩展和丰富知识库的能力，以及改善非编程状态下的系统性能，即自学习能力。
    - 专家系统能不断增长知识，修改原有知识，不断更新

##### 专家系统的优点
* 专家系统能够高效率、准确、周到、迅速和不知疲倦地进行工作。
* 专家系统解决实际问题时不受周围环境的影响，也不可能遗漏和忘记。
* 可以使专家的专长不受时间和空间的限制，以便推广珍贵和稀缺的专家知识与经验。
* 专家系统能促进各领域的发展，使各领域专家的专业知识和经验得到总结和精炼，能够广泛有力地传播专家的知识、经验和能力。
* 专家系统能汇集多领域专家的知识和经验以及他们协作解决重大问题的能力，它拥有更渊博的知识、更丰富的经验和更强的工作能力。
* 军事专家系统的水平是一个国家国防现代化的重要标志之一。
* 专家系统的研制和应用，具有巨大的经济效益和社会效益。
* 研究专家系统能够促进整个科学技术的发展。专家系统对人工智能各个领域的发展起了很大的促进作用，并将对科技、经济、国防、教育、社会和人民生活产生极其深远的影响。

##### 专家系统的结构

* 专家系统简化结构图
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E4%B8%93%E5%AE%B61.jpg)
* 理想专家系统的结构图
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E4%B8%93%E5%AE%B62.jpg)
* 专家系统的主要组成部分：
    - 知识库
    - 综合数据库
    - 推理机
    - 解释器
    - 接口

##### 专家系统的建造步骤
* 设计初始知识库
    - 问题知识化
    - 知识概念化
    - 概念形式化
    - 形式规则化
    - 规则合法化
* 原型机（prototype）的开发与实验
* 知识库的改进与归纳
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E4%B8%93%E5%AE%B63.jpg)

#### 基于规则的专家系统基于框架的专家系统

一个基于规则的专家系统采用下列模块来建立产生式系统的模型：
1. 知识库：以一套规则建立人的长期存储器模型。
2. 工作存储器：建立人的短期存储器模型，存放问题事实和由规则激发而推断出的新事实。
3. 推理机：借助于把存放在工作存储器内的问题事实和存放在知识库内的规则结合起来，建立人的推理模型，以推断出新的信息 。

#### 基于框架的专家系统

* 基于框架的专家系统是一个计算机程序，该程序使用一组包含在知识库内的框架对工作存储器内的具体问题信息进行处理，通过推理机推断出新的信息。
* 基于框架的专家系统是建立在框架的基础之上的。一般概念存放在框架内，而该概念的一些特例则被表示在其他框架内并含有实际的特征值。
* 基于框架的专家系统能够提供基于规则专家系统所没有的特征，如继承、侧面、信息通信和模式匹配规则等，因而，基于框架的专家系统比基于规则的专家系统拥有更强的功能，适用于解决更复杂的问题。

#### 基于模型的专家系统

* 关于人工智能的一个观点:  认为人工智能是对各种定性模型（物理的、感知的、认识的和社会的系统模型）的获得、表达及使用的计算方法进行研究的学问。一个知识系统中的知识库是由各种模型综合而成的。
* 模型类型：基于逻辑的心理模型、定性的物理模型、神经元网络模型、可视知识模型等等。
* 综合各种模型的专家系统比基于逻辑心理模型的系统具有更强的功能，从而有可能显著改进专家系统的设计
* 在诸多模型中，人工神经网络模型的应用最为广泛

#### 基于Web的专家系统
#### 新型专家系统
#### 专家系统的设计
#### 专家系统的开发工具


### 模糊逻辑系统

#### 模糊逻辑原理

模糊逻辑的发展，是由理论准备到理论提出再到理论应用的过程
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A1.jpg)

#### 模糊集
* 从精确到模糊
    - 精确
        + 答案确定：要么是，要么不是
        + `f : A → {0,1}`
        + 如：他是学生？不是学生？
    - 模糊
        + 答案不定：也许是，也许不是，也许介于之间
        + `μA : U → [0,1]`
        + 如：他是成年人？不是成年人？大概是成年人？

---

【例子】表示“20岁左右”
* 原集合（年龄）
    - {...., 17, 18, 19, 20, 21, 22, 23, ...}
* 模糊集可以表示为：
    - 0.8/18 + 0.9/19 + 1/20 + 0.9/21 + 0.8/12
    - 0.6/17+0.7/18+0.8/19+1/20+0.9/21+0.7/22+0.6/23

---

##### 集合及其特征函数
* 在论域中，把具有某种属性的事物的全体称为集合。由于集合中的元素都具有某种属性，因此可以用集合表示某一种概念，而且可用一个函数来刻画它，该函数称为特征函数。
* 设A是论域U上的一个集合，对任意u∈U，令
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A2.jpg)
* 则称CA(u)为集合A的特征函数。特征函数CA(u)在u=u0处的取值CA(u0)称为u0对A的隶属度。
* 集合A与其特征函数可以认为是等价的：A={u |CA(u)=1}

##### 模糊集与隶属函数
* 模糊集把特征函数的取值范围从{0,1}推广到[0,1]上。
* 设U是论域，μA是把任意u∈U映射为[0,1]上某个值的函数，即
`μA : U→[0,1]   或   u→μA(u)`
* 则称μA为定义在U上的一个隶属函数，由μA(u)(u∈U)所构成的集合A称为U上的一个模糊集，μA(u)称为u对A的隶属度。

---

【例子】
论域U={1,2,3,4,5}，用模糊集表示“大”和“小”。

解：设A、B分别表示“大”与“小”的模糊集，μA ，μB分别为相应的隶属函数。
`A = {0, 0, 0.1, 0.6, 1}`
`B = {1, 0.5, 0.01, 0, 0}`
其中：
`μA(1)=0, μA(2)=0 , μA(3)=0.1 , μA(4)=0.6 , μA(5)=1`
`μB(1)=1, μB(2)=0.5 , μB(3)=0.01 , μB(4)=0, μB(5)=0`

---

##### 模糊集的表示方法
(1)、论域离散且为有限
若论域 U={u1, … , un}为离散论域，模糊集A表示为：
`A= {μA(u1), μA(u2), … ,  μA(un)}`
也可写为：
`A= μA(u1)/u1 + μA(u2)/u2 + … + μA(un)/un`
其中，隶属度为0的元素可以不写。

例如：
```
A = 1/u1+0.7/u2+0/u3+0.4/u4
  = 1/u1+0.7/u2+0.4/u4
```

(2)、论域连续
若论域是连续的，则模糊集可用实函数表示。
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A3.jpg)
例如：以年龄为论域U=[0,100]， “年轻”和“年老”这两个概念可表示为：
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A%E4%BE%8B%E5%AD%90.jpg)

(3)、一般表示方法
不管论域 U 是有限的还是无限的，是连续的亦或是离散的，扎德（ L. A. Zadeh ）又给出了一种类似于积分的一般表示形式：
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A8.jpg)
这里的记号不是数学中的积分符号，也不是求和，只是表示论域中各元素与其隶属度对应关系的总括。

##### 模糊集的运算
* 模糊集的包含运算
    - 设A、B分别是U 上的两个模糊集，对任意u∈U，都有 μB(u) ≤ μA(u) 成立，则称A包含B，记为B     A。
* 模糊集的交、并、补运算
    - 设A、B分别是U上的两个模糊集，则A和B两个集合的并集A∪B、交集A∩B和A的补集﹁A的隶属函数分别为： 
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A9.jpg)

---

【例子】
设U={u1,u2,u3}，
A=0.3/u1+0.8/u2+0.6/u3;    B=0.6/u1+0.4/u2+0.7/u3
求A∩B，A∪B和¬A。
```
A∩B = (0.3∧0.6)/u1+(0.8∧0.4)/u2+(0.6∧0.7)/u3
    = 0.3/u1+0.4/u2+0.6/u3
A∪B = (0.3∨0.6)/u1+(0.8∨0.4)/u2+(0.6∨0.7)/u3
    = 0.6/u1+0.8/u2+0.7/u3
¬A  = (1-0.3)/u1+(1-0.8)/u2+(1-0.6)/u3
    = 0.7/u1+0.2/u2+0.4/u3
```

---

#### 模糊关系
##### 模糊关系的定义
* 设 Ai 是 Ui (i=1,2,…,n) 上的模糊集，则称![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A4.jpg)为A1, A2, …, An的笛卡尔乘积，它是U1×U2×…×Un上的一个模糊集。 

* 在U1×…×Un上一个n元模糊关系R是指以U1×…×Un为论域的一个模糊集，记为:
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A5.jpg)

一般地说，当U和V都是有限论域时，`U={u1,u2,…,um}`，`V={v1,v2,…,vn}`，则U×V上的模糊关系R可用一个模糊矩阵表示
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A6.jpg)

##### 模糊关系的合成
* 设R1与R2分别是U×V与V×W上的两个模糊关系，则R1与R2的合成是指从U到W的一个模糊关系，记为`R1°R2`
* 其隶属函数为
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A7.jpg)
* 隶属函数计算方法：取R1的第 i 行元素分别与R2的第 j 列元素相比较，两个数中取其小者，然后再在所得的一组最小数中取最大的一个，以此作为R1°R2的第 i 行第 j 列的元素。

---

【例子】
设有两个模糊关系
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A%E4%BE%8B%E5%AD%901.jpg)
则R1与R2的合成是
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A%E4%BE%8B%E5%AD%902.jpg)

---

#### 模糊变换

##### 模糊变换的概念
设`A={μA(u1),μA(u2),…,μA(un)}`是论域U上的模糊集，R是`U×V`上的模糊关系，则`A°R = B`称为模糊变换。

例如：设A={0.2,0.5,0.3}
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A10.jpg)

##### 用模糊变换可进行模糊推理
例如：设对某厨师做的一道菜进行评判
评判标准是：色（u1）、香（u2） 、味（u3），它们构成论域：U= { u1, u2 , u3}。
评判时由评委对每一个评判因素分别进行打分，评判等级是好（v1）、较好（v2） 、一般（v3）、差（v4），它们构成论域：V= {v1, v2 , v3 , v4}。
仅就色而言，有60%的评委认为这道菜“好”， 20%的评委认为 “较好”，20%的评委认为 “一般”，没有评委认为 “差”，则对“色”的评价为：{0.6 , 0.2, 0.2, 0}
对“香”的评价为：{0.8 , 0.1, 0.1, 0}
对“味”的评价为：{0.3 , 0.3, 0.3, 0.1}
这样就可以写出矩阵R：
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A11.jpg)
假设三个评判因素在评判中所占的权重分别是：“色”为0.3，“香”为0.3，“味”为0.4。这三个权重组成了U上的一个模糊向量：A={0.3 , 0.3, 0.4}
由此可得到评委对这道菜的综合评判为：
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A12.jpg)
在此例中，评判结果的各项和刚好为1，所以它就是最终评判结果。
如果不是这样，还需要对其进行归一化处理，将归一化后的结果作为最终评判结果。

#### 模糊推理

##### 简单模糊推理(扎德法)
>知识中只含有简单条件，且不带可信度因子的模糊推理称为简单模糊推理。
>关于如何由已知的模糊知识和证据具体地推出模糊结论，目前已经提出了多种推理方法。其中包括扎德（ L. A. Zadeh ）等人提出的合成推理规则。

扎德：基于模糊关系合成推理的基本思想
* 对于知识 “`IF x is A  THEN y is B`”，首先构造出A与B之间的模糊关系R；
* 再将R与证据合成，求出结论。

*合成推理规则*：
对于知识`IF x is A  THEN y is B`
* 首先构造出A与B之间的模糊关系R，然后通过R与证据的合成求出结论。
* 如果已知证据是` x is A’`，且A与A’可以模糊匹配，则通过下述合成运算求取B'：
`B'= A’ ◦R`
* 如果已知证据是` y is B'`，且B与B'可以模糊匹配，则通过下述合成运算求出A’：
` A’ =R◦B'`

至于如何构造模糊关系R：
>条件命题的极大极小规则：记获得的模糊关系为Rm

设`A∈F(U)`, `B∈F(V)`，其表示分别为
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A13.jpg)
扎德把Rm定义为：
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A14.jpg)

---

【例子】
设`U=V={1,2,3,4,5}`, `A=1/1+0.5/2`, `B=0.4/3+0.6/4+1/5`
并设模糊知识为：`IF  x is A  THEN  y is B `
模糊证据为：`x is A’`
其中， A’的模糊集为： `A’ =1/1+0.4/2+0.2/3`

则：由模糊知识可得到 Rm
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A15.jpg)

求B'：B'= A’ ◦R
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A16.jpg)

若已知证据为: y is B'
`B'=0.2/1+0.4/2+0.6/3+0.5/4 +0.3/5`
则：![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A17.jpg)

---


#### 模糊计算的流程
##### 模糊计算适用于：
1. 复杂且没有完整数学模型的非线性问题：可在不知晓具体模型的情况下利用经验规则求解；
2. 与其它智能算法结合实现优势互补: 提供了将人类在识别、决策、理解等方面的模糊性引入机器及其控制的途径。

##### 模糊计算的过程可以分为四个模块:
* 模糊规则库：
    - 是专家提供的模糊规则。
* 模糊化：
    - 是根据隶属度函数从具体的输入得到对模糊集隶属度的过程。
* 推理方法：
    - 是从模糊规则和输入对相关模糊集的隶属度得到模糊结论的方法。
* 去模糊化：
    - 就是将模糊结论转化为具体的、精确的输出的过程。

##### 模糊计算的一般流程：
![](http://p7n85i5tr.bkt.clouddn.com/zhouie/img/ai/%E6%A8%A1%E7%B3%8A18.jpg)
